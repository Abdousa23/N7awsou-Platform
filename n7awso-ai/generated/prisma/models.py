# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _int
    username: _str
    email: _str
    createdAt: datetime.datetime
    hash: _str
    hashedRt: Optional[_str] = None
    role: 'enums.Role'
    History: Optional[List['models.History']] = None
    GuideTours: Optional[List['models.GuideTours']] = None
    TouristTours: Optional[List['models.TouristTours']] = None
    Payments: Optional[List['models.Payment']] = None
    Reviews: Optional[List['models.Rating']] = None
    emailSubscribed: _bool
    emailVerified: _bool
    unsubscribedAt: Optional[datetime.datetime] = None
    lastEmailSent: Optional[datetime.datetime] = None
    EmailCampaignSends: Optional[List['models.EmailCampaignSend']] = None
    UserPreferences: Optional['models.UserPreferences'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class History(bases.BaseHistory):
    """Represents a History record"""

    id: _int
    userId: _int
    tourId: _int
    viewedAt: Optional[datetime.datetime] = None
    interaction: _int
    enrolled: _bool
    enrolledAt: Optional[datetime.datetime] = None
    user: Optional['models.User'] = None
    tour: Optional['models.Tour'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.HistoryKeys']] = None,
        exclude: Optional[Iterable['types.HistoryKeys']] = None,
        required: Optional[Iterable['types.HistoryKeys']] = None,
        optional: Optional[Iterable['types.HistoryKeys']] = None,
        relations: Optional[Mapping['types.HistoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.HistoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _History_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _History_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _History_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _History_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _History_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _History_relational_fields:
                        raise errors.UnknownRelationalFieldError('History', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid History / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'History',
            }
        )
        _created_partial_types.add(name)


class GuideTours(bases.BaseGuideTours):
    """Represents a GuideTours record"""

    id: _int
    guideId: _int
    tourId: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    guide: Optional['models.User'] = None
    tour: Optional['models.Tour'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.GuideToursKeys']] = None,
        exclude: Optional[Iterable['types.GuideToursKeys']] = None,
        required: Optional[Iterable['types.GuideToursKeys']] = None,
        optional: Optional[Iterable['types.GuideToursKeys']] = None,
        relations: Optional[Mapping['types.GuideToursRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.GuideToursKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _GuideTours_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _GuideTours_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _GuideTours_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _GuideTours_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _GuideTours_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _GuideTours_relational_fields:
                        raise errors.UnknownRelationalFieldError('GuideTours', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid GuideTours / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'GuideTours',
            }
        )
        _created_partial_types.add(name)


class Tour(bases.BaseTour):
    """Represents a Tour record"""

    id: _int
    name: _str
    description: _str
    price: _float
    departureDate: datetime.datetime
    returnDate: datetime.datetime
    departureLocation: _str
    destinationLocation: _str
    includedFeatures: List[_str]
    category: Optional[_str] = None
    tripType: 'enums.TripType'
    images: List[_str]
    dressCode: Optional[_str] = None
    available: _bool
    duration: _int
    availableCapacity: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    History: Optional[List['models.History']] = None
    sellerId: Optional[_int] = None
    seller: Optional['models.Seller'] = None
    GuideTours: Optional[List['models.GuideTours']] = None
    TouristTours: Optional[List['models.TouristTours']] = None
    Payments: Optional[List['models.Payment']] = None
    Ratings: Optional[List['models.Rating']] = None
    AIContent: Optional['models.AIContent'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('includedFeatures', 'images', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TourKeys']] = None,
        exclude: Optional[Iterable['types.TourKeys']] = None,
        required: Optional[Iterable['types.TourKeys']] = None,
        optional: Optional[Iterable['types.TourKeys']] = None,
        relations: Optional[Mapping['types.TourRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TourKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Tour_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Tour_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Tour_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Tour_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Tour_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Tour_relational_fields:
                        raise errors.UnknownRelationalFieldError('Tour', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Tour / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Tour',
            }
        )
        _created_partial_types.add(name)


class TouristTours(bases.BaseTouristTours):
    """Represents a TouristTours record"""

    id: _int
    touristId: _int
    tourId: _int
    status: 'enums.TouristTourStatus'
    tourist: Optional['models.User'] = None
    tour: Optional['models.Tour'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TouristToursKeys']] = None,
        exclude: Optional[Iterable['types.TouristToursKeys']] = None,
        required: Optional[Iterable['types.TouristToursKeys']] = None,
        optional: Optional[Iterable['types.TouristToursKeys']] = None,
        relations: Optional[Mapping['types.TouristToursRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TouristToursKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _TouristTours_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _TouristTours_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _TouristTours_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _TouristTours_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _TouristTours_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _TouristTours_relational_fields:
                        raise errors.UnknownRelationalFieldError('TouristTours', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid TouristTours / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'TouristTours',
            }
        )
        _created_partial_types.add(name)


class Payment(bases.BasePayment):
    """Represents a Payment record"""

    id: _int
    userId: _int
    tourId: _int
    amount: _float
    numberOfPeople: _int
    currency: _str
    status: 'enums.PaymentStatus'
    transactionId: Optional[_str] = None
    gatewayResponse: Optional['fields.Json'] = None
    createdAt: datetime.datetime
    processedAt: Optional[datetime.datetime] = None
    failedAt: Optional[datetime.datetime] = None
    refundedAt: Optional[datetime.datetime] = None
    refundAmount: Optional[_float] = None
    notes: Optional[_str] = None
    user: Optional['models.User'] = None
    tour: Optional['models.Tour'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PaymentKeys']] = None,
        exclude: Optional[Iterable['types.PaymentKeys']] = None,
        required: Optional[Iterable['types.PaymentKeys']] = None,
        optional: Optional[Iterable['types.PaymentKeys']] = None,
        relations: Optional[Mapping['types.PaymentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PaymentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Payment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Payment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Payment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Payment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Payment_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Payment_relational_fields:
                        raise errors.UnknownRelationalFieldError('Payment', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Payment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Payment',
            }
        )
        _created_partial_types.add(name)


class StaffMember(bases.BaseStaffMember):
    """Represents a StaffMember record"""

    id: _int
    name: _str
    email: _str
    password: _str
    Seller: Optional['models.Seller'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.StaffMemberKeys']] = None,
        exclude: Optional[Iterable['types.StaffMemberKeys']] = None,
        required: Optional[Iterable['types.StaffMemberKeys']] = None,
        optional: Optional[Iterable['types.StaffMemberKeys']] = None,
        relations: Optional[Mapping['types.StaffMemberRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.StaffMemberKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _StaffMember_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _StaffMember_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _StaffMember_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _StaffMember_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _StaffMember_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _StaffMember_relational_fields:
                        raise errors.UnknownRelationalFieldError('StaffMember', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid StaffMember / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'StaffMember',
            }
        )
        _created_partial_types.add(name)


class Seller(bases.BaseSeller):
    """Represents a Seller record"""

    id: _int
    StaffMemberId: _int
    StaffMember: Optional['models.StaffMember'] = None
    tours: Optional[List['models.Tour']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SellerKeys']] = None,
        exclude: Optional[Iterable['types.SellerKeys']] = None,
        required: Optional[Iterable['types.SellerKeys']] = None,
        optional: Optional[Iterable['types.SellerKeys']] = None,
        relations: Optional[Mapping['types.SellerRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SellerKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Seller_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Seller_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Seller_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Seller_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Seller_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Seller_relational_fields:
                        raise errors.UnknownRelationalFieldError('Seller', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Seller / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Seller',
            }
        )
        _created_partial_types.add(name)


class Rating(bases.BaseRating):
    """Represents a Rating record"""

    id: _int
    rating: _int
    review: Optional[_str] = None
    userId: _int
    user: Optional['models.User'] = None
    tourId: _int
    tour: Optional['models.Tour'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RatingKeys']] = None,
        exclude: Optional[Iterable['types.RatingKeys']] = None,
        required: Optional[Iterable['types.RatingKeys']] = None,
        optional: Optional[Iterable['types.RatingKeys']] = None,
        relations: Optional[Mapping['types.RatingRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RatingKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Rating_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Rating_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Rating_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Rating_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Rating_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Rating_relational_fields:
                        raise errors.UnknownRelationalFieldError('Rating', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Rating / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Rating',
            }
        )
        _created_partial_types.add(name)


class ChatSession(bases.BaseChatSession):
    """Represents a ChatSession record"""

    id: _str
    sessionId: _str
    userId: Optional[_str] = None
    createdAt: datetime.datetime
    lastActivity: datetime.datetime
    isActive: _bool
    messages: Optional[List['models.ChatMessage']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ChatSessionKeys']] = None,
        exclude: Optional[Iterable['types.ChatSessionKeys']] = None,
        required: Optional[Iterable['types.ChatSessionKeys']] = None,
        optional: Optional[Iterable['types.ChatSessionKeys']] = None,
        relations: Optional[Mapping['types.ChatSessionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ChatSessionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ChatSession_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ChatSession_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ChatSession_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ChatSession_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ChatSession_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ChatSession_relational_fields:
                        raise errors.UnknownRelationalFieldError('ChatSession', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ChatSession / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ChatSession',
            }
        )
        _created_partial_types.add(name)


class ChatMessage(bases.BaseChatMessage):
    """Represents a ChatMessage record"""

    id: _int
    sessionId: _str
    messageId: _str
    role: _str
    content: _str
    timestamp: datetime.datetime
    session: Optional['models.ChatSession'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ChatMessageKeys']] = None,
        exclude: Optional[Iterable['types.ChatMessageKeys']] = None,
        required: Optional[Iterable['types.ChatMessageKeys']] = None,
        optional: Optional[Iterable['types.ChatMessageKeys']] = None,
        relations: Optional[Mapping['types.ChatMessageRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ChatMessageKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ChatMessage_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ChatMessage_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ChatMessage_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ChatMessage_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ChatMessage_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ChatMessage_relational_fields:
                        raise errors.UnknownRelationalFieldError('ChatMessage', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ChatMessage / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ChatMessage',
            }
        )
        _created_partial_types.add(name)


class UserPreferences(bases.BaseUserPreferences):
    """Represents a UserPreferences record"""

    id: _int
    userId: _int
    budgetRange: Optional[_str] = None
    preferredTripTypes: List[_str]
    preferredCategories: List[_str]
    preferredDestinations: List[_str]
    travelStyle: Optional[_str] = None
    groupSize: Optional[_str] = None
    preferredDuration: Optional[_str] = None
    accessibility: List[_str]
    dietaryRestrictions: List[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('preferredTripTypes', 'preferredCategories', 'preferredDestinations', 'accessibility', 'dietaryRestrictions', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserPreferencesKeys']] = None,
        exclude: Optional[Iterable['types.UserPreferencesKeys']] = None,
        required: Optional[Iterable['types.UserPreferencesKeys']] = None,
        optional: Optional[Iterable['types.UserPreferencesKeys']] = None,
        relations: Optional[Mapping['types.UserPreferencesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserPreferencesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserPreferences_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserPreferences_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserPreferences_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserPreferences_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserPreferences_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserPreferences_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserPreferences', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserPreferences / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserPreferences',
            }
        )
        _created_partial_types.add(name)


class AIContent(bases.BaseAIContent):
    """Represents a AIContent record"""

    id: _int
    tourId: _int
    personalizedDesc: Optional[_str] = None
    highlights: List[_str]
    recommendations: List[_str]
    targetAudience: List[_str]
    suggestedTags: List[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    tour: Optional['models.Tour'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('highlights', 'recommendations', 'targetAudience', 'suggestedTags', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AIContentKeys']] = None,
        exclude: Optional[Iterable['types.AIContentKeys']] = None,
        required: Optional[Iterable['types.AIContentKeys']] = None,
        optional: Optional[Iterable['types.AIContentKeys']] = None,
        relations: Optional[Mapping['types.AIContentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AIContentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AIContent_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AIContent_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AIContent_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AIContent_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AIContent_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AIContent_relational_fields:
                        raise errors.UnknownRelationalFieldError('AIContent', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AIContent / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AIContent',
            }
        )
        _created_partial_types.add(name)


class EmailCampaign(bases.BaseEmailCampaign):
    """Represents a EmailCampaign record"""

    id: _int
    name: _str
    subject: _str
    content: _str
    htmlContent: Optional[_str] = None
    status: 'enums.EmailCampaignStatus'
    targetAudience: Optional['fields.Json'] = None
    scheduledAt: Optional[datetime.datetime] = None
    sentAt: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    totalRecipients: _int
    sentCount: _int
    deliveredCount: _int
    openedCount: _int
    clickedCount: _int
    unsubscribedCount: _int
    sends: Optional[List['models.EmailCampaignSend']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailCampaignKeys']] = None,
        exclude: Optional[Iterable['types.EmailCampaignKeys']] = None,
        required: Optional[Iterable['types.EmailCampaignKeys']] = None,
        optional: Optional[Iterable['types.EmailCampaignKeys']] = None,
        relations: Optional[Mapping['types.EmailCampaignRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailCampaignKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmailCampaign_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmailCampaign_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmailCampaign_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmailCampaign_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _EmailCampaign_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _EmailCampaign_relational_fields:
                        raise errors.UnknownRelationalFieldError('EmailCampaign', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmailCampaign / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmailCampaign',
            }
        )
        _created_partial_types.add(name)


class EmailCampaignSend(bases.BaseEmailCampaignSend):
    """Represents a EmailCampaignSend record"""

    id: _int
    campaignId: _int
    userId: _int
    status: 'enums.EmailSendStatus'
    sentAt: Optional[datetime.datetime] = None
    deliveredAt: Optional[datetime.datetime] = None
    openedAt: Optional[datetime.datetime] = None
    clickedAt: Optional[datetime.datetime] = None
    unsubscribedAt: Optional[datetime.datetime] = None
    bounceReason: Optional[_str] = None
    errorMessage: Optional[_str] = None
    createdAt: datetime.datetime
    campaign: Optional['models.EmailCampaign'] = None
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailCampaignSendKeys']] = None,
        exclude: Optional[Iterable['types.EmailCampaignSendKeys']] = None,
        required: Optional[Iterable['types.EmailCampaignSendKeys']] = None,
        optional: Optional[Iterable['types.EmailCampaignSendKeys']] = None,
        relations: Optional[Mapping['types.EmailCampaignSendRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailCampaignSendKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmailCampaignSend_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmailCampaignSend_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmailCampaignSend_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmailCampaignSend_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _EmailCampaignSend_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _EmailCampaignSend_relational_fields:
                        raise errors.UnknownRelationalFieldError('EmailCampaignSend', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmailCampaignSend / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmailCampaignSend',
            }
        )
        _created_partial_types.add(name)


class EmailTemplate(bases.BaseEmailTemplate):
    """Represents a EmailTemplate record"""

    id: _int
    name: _str
    subject: _str
    content: _str
    htmlContent: Optional[_str] = None
    type: 'enums.EmailTemplateType'
    variables: List[_str]
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('variables', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.EmailTemplateKeys']] = None,
        exclude: Optional[Iterable['types.EmailTemplateKeys']] = None,
        required: Optional[Iterable['types.EmailTemplateKeys']] = None,
        optional: Optional[Iterable['types.EmailTemplateKeys']] = None,
        relations: Optional[Mapping['types.EmailTemplateRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.EmailTemplateKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _EmailTemplate_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _EmailTemplate_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _EmailTemplate_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _EmailTemplate_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "EmailTemplate" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid EmailTemplate / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'EmailTemplate',
            }
        )
        _created_partial_types.add(name)


class AutomationRules(bases.BaseAutomationRules):
    """Represents a AutomationRules record"""

    id: _int
    name: _str
    description: Optional[_str] = None
    triggerType: _str
    conditions: 'fields.Json'
    actions: 'fields.Json'
    isActive: _bool
    lastExecuted: Optional[datetime.datetime] = None
    executionCount: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    logs: Optional[List['models.AutomationLogs']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AutomationRulesKeys']] = None,
        exclude: Optional[Iterable['types.AutomationRulesKeys']] = None,
        required: Optional[Iterable['types.AutomationRulesKeys']] = None,
        optional: Optional[Iterable['types.AutomationRulesKeys']] = None,
        relations: Optional[Mapping['types.AutomationRulesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AutomationRulesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AutomationRules_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AutomationRules_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AutomationRules_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AutomationRules_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AutomationRules_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AutomationRules_relational_fields:
                        raise errors.UnknownRelationalFieldError('AutomationRules', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AutomationRules / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AutomationRules',
            }
        )
        _created_partial_types.add(name)


class AutomationLogs(bases.BaseAutomationLogs):
    """Represents a AutomationLogs record"""

    id: _int
    ruleId: _int
    action: _str
    status: _str
    details: Optional['fields.Json'] = None
    error: Optional[_str] = None
    executedAt: datetime.datetime
    rule: Optional['models.AutomationRules'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AutomationLogsKeys']] = None,
        exclude: Optional[Iterable['types.AutomationLogsKeys']] = None,
        required: Optional[Iterable['types.AutomationLogsKeys']] = None,
        optional: Optional[Iterable['types.AutomationLogsKeys']] = None,
        relations: Optional[Mapping['types.AutomationLogsRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AutomationLogsKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AutomationLogs_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AutomationLogs_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AutomationLogs_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AutomationLogs_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AutomationLogs_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AutomationLogs_relational_fields:
                        raise errors.UnknownRelationalFieldError('AutomationLogs', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AutomationLogs / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AutomationLogs',
            }
        )
        _created_partial_types.add(name)


class ContentTemplates(bases.BaseContentTemplates):
    """Represents a ContentTemplates record"""

    id: _int
    name: _str
    type: _str
    template: _str
    variables: List[_str]
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )

    @field_validator('variables', pre=True, allow_reuse=True)
    @classmethod
    def _transform_required_list_fields(cls, value: object) -> object:
        # When using raw queries, some databases will return `None` for an array field that has not been set yet.
        #
        # In our case we want to use an empty list instead as that is the internal Prisma behaviour and we want
        # to use the same consistent structure between the core ORM and raw queries. For example, if we updated
        # our type definitions to include `None` for `List` fields then it would be misleading as it will only
        # ever be `None` in raw queries.
        if value is None:
            return []

        return value

    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ContentTemplatesKeys']] = None,
        exclude: Optional[Iterable['types.ContentTemplatesKeys']] = None,
        required: Optional[Iterable['types.ContentTemplatesKeys']] = None,
        optional: Optional[Iterable['types.ContentTemplatesKeys']] = None,
        relations: Optional[Mapping['types.ContentTemplatesRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ContentTemplatesKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ContentTemplates_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ContentTemplates_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ContentTemplates_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ContentTemplates_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "ContentTemplates" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ContentTemplates / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ContentTemplates',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'History',
        'GuideTours',
        'TouristTours',
        'Payments',
        'Reviews',
        'EmailCampaignSends',
        'UserPreferences',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('hash', {
            'name': 'hash',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('hashedRt', {
            'name': 'hashedRt',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.Role',
            'is_relational': False,
            'documentation': None,
        }),
        ('History', {
            'name': 'History',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.History\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('GuideTours', {
            'name': 'GuideTours',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.GuideTours\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('TouristTours', {
            'name': 'TouristTours',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TouristTours\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Payments', {
            'name': 'Payments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Payment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Reviews', {
            'name': 'Reviews',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Rating\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('emailSubscribed', {
            'name': 'emailSubscribed',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('emailVerified', {
            'name': 'emailVerified',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('unsubscribedAt', {
            'name': 'unsubscribedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastEmailSent', {
            'name': 'lastEmailSent',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('EmailCampaignSends', {
            'name': 'EmailCampaignSends',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailCampaignSend\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('UserPreferences', {
            'name': 'UserPreferences',
            'is_list': False,
            'optional': True,
            'type': 'models.UserPreferences',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_History_relational_fields: Set[str] = {
        'user',
        'tour',
    }
_History_fields: Dict['types.HistoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tourId', {
            'name': 'tourId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('viewedAt', {
            'name': 'viewedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('interaction', {
            'name': 'interaction',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('enrolled', {
            'name': 'enrolled',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('enrolledAt', {
            'name': 'enrolledAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('tour', {
            'name': 'tour',
            'is_list': False,
            'optional': True,
            'type': 'models.Tour',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_GuideTours_relational_fields: Set[str] = {
        'guide',
        'tour',
    }
_GuideTours_fields: Dict['types.GuideToursKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('guideId', {
            'name': 'guideId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tourId', {
            'name': 'tourId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('guide', {
            'name': 'guide',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('tour', {
            'name': 'tour',
            'is_list': False,
            'optional': True,
            'type': 'models.Tour',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Tour_relational_fields: Set[str] = {
        'History',
        'seller',
        'GuideTours',
        'TouristTours',
        'Payments',
        'Ratings',
        'AIContent',
    }
_Tour_fields: Dict['types.TourKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('price', {
            'name': 'price',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('departureDate', {
            'name': 'departureDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('returnDate', {
            'name': 'returnDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('departureLocation', {
            'name': 'departureLocation',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('destinationLocation', {
            'name': 'destinationLocation',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('includedFeatures', {
            'name': 'includedFeatures',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tripType', {
            'name': 'tripType',
            'is_list': False,
            'optional': False,
            'type': 'enums.TripType',
            'is_relational': False,
            'documentation': None,
        }),
        ('images', {
            'name': 'images',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('dressCode', {
            'name': 'dressCode',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('available', {
            'name': 'available',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('duration', {
            'name': 'duration',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('availableCapacity', {
            'name': 'availableCapacity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('History', {
            'name': 'History',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.History\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('sellerId', {
            'name': 'sellerId',
            'is_list': False,
            'optional': True,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('seller', {
            'name': 'seller',
            'is_list': False,
            'optional': True,
            'type': 'models.Seller',
            'is_relational': True,
            'documentation': None,
        }),
        ('GuideTours', {
            'name': 'GuideTours',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.GuideTours\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('TouristTours', {
            'name': 'TouristTours',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TouristTours\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Payments', {
            'name': 'Payments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Payment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Ratings', {
            'name': 'Ratings',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Rating\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('AIContent', {
            'name': 'AIContent',
            'is_list': False,
            'optional': True,
            'type': 'models.AIContent',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_TouristTours_relational_fields: Set[str] = {
        'tourist',
        'tour',
    }
_TouristTours_fields: Dict['types.TouristToursKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('touristId', {
            'name': 'touristId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tourId', {
            'name': 'tourId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.TouristTourStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('tourist', {
            'name': 'tourist',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('tour', {
            'name': 'tour',
            'is_list': False,
            'optional': True,
            'type': 'models.Tour',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Payment_relational_fields: Set[str] = {
        'user',
        'tour',
    }
_Payment_fields: Dict['types.PaymentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tourId', {
            'name': 'tourId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('amount', {
            'name': 'amount',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('numberOfPeople', {
            'name': 'numberOfPeople',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('currency', {
            'name': 'currency',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.PaymentStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('transactionId', {
            'name': 'transactionId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('gatewayResponse', {
            'name': 'gatewayResponse',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('processedAt', {
            'name': 'processedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('failedAt', {
            'name': 'failedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('refundedAt', {
            'name': 'refundedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('refundAmount', {
            'name': 'refundAmount',
            'is_list': False,
            'optional': True,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('notes', {
            'name': 'notes',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('tour', {
            'name': 'tour',
            'is_list': False,
            'optional': True,
            'type': 'models.Tour',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_StaffMember_relational_fields: Set[str] = {
        'Seller',
    }
_StaffMember_fields: Dict['types.StaffMemberKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Seller', {
            'name': 'Seller',
            'is_list': False,
            'optional': True,
            'type': 'models.Seller',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Seller_relational_fields: Set[str] = {
        'StaffMember',
        'tours',
    }
_Seller_fields: Dict['types.SellerKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('StaffMemberId', {
            'name': 'StaffMemberId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('StaffMember', {
            'name': 'StaffMember',
            'is_list': False,
            'optional': True,
            'type': 'models.StaffMember',
            'is_relational': True,
            'documentation': None,
        }),
        ('tours', {
            'name': 'tours',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Tour\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Rating_relational_fields: Set[str] = {
        'user',
        'tour',
    }
_Rating_fields: Dict['types.RatingKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rating', {
            'name': 'rating',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('review', {
            'name': 'review',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('tourId', {
            'name': 'tourId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tour', {
            'name': 'tour',
            'is_list': False,
            'optional': True,
            'type': 'models.Tour',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ChatSession_relational_fields: Set[str] = {
        'messages',
    }
_ChatSession_fields: Dict['types.ChatSessionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sessionId', {
            'name': 'sessionId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastActivity', {
            'name': 'lastActivity',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('messages', {
            'name': 'messages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ChatMessage\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ChatMessage_relational_fields: Set[str] = {
        'session',
    }
_ChatMessage_fields: Dict['types.ChatMessageKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sessionId', {
            'name': 'sessionId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('messageId', {
            'name': 'messageId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('timestamp', {
            'name': 'timestamp',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('session', {
            'name': 'session',
            'is_list': False,
            'optional': True,
            'type': 'models.ChatSession',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserPreferences_relational_fields: Set[str] = {
        'user',
    }
_UserPreferences_fields: Dict['types.UserPreferencesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('budgetRange', {
            'name': 'budgetRange',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('preferredTripTypes', {
            'name': 'preferredTripTypes',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('preferredCategories', {
            'name': 'preferredCategories',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('preferredDestinations', {
            'name': 'preferredDestinations',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('travelStyle', {
            'name': 'travelStyle',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('groupSize', {
            'name': 'groupSize',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('preferredDuration', {
            'name': 'preferredDuration',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('accessibility', {
            'name': 'accessibility',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('dietaryRestrictions', {
            'name': 'dietaryRestrictions',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_AIContent_relational_fields: Set[str] = {
        'tour',
    }
_AIContent_fields: Dict['types.AIContentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('tourId', {
            'name': 'tourId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('personalizedDesc', {
            'name': 'personalizedDesc',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('highlights', {
            'name': 'highlights',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('recommendations', {
            'name': 'recommendations',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('targetAudience', {
            'name': 'targetAudience',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('suggestedTags', {
            'name': 'suggestedTags',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('tour', {
            'name': 'tour',
            'is_list': False,
            'optional': True,
            'type': 'models.Tour',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_EmailCampaign_relational_fields: Set[str] = {
        'sends',
    }
_EmailCampaign_fields: Dict['types.EmailCampaignKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('subject', {
            'name': 'subject',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('htmlContent', {
            'name': 'htmlContent',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.EmailCampaignStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('targetAudience', {
            'name': 'targetAudience',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('scheduledAt', {
            'name': 'scheduledAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('sentAt', {
            'name': 'sentAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalRecipients', {
            'name': 'totalRecipients',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sentCount', {
            'name': 'sentCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('deliveredCount', {
            'name': 'deliveredCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('openedCount', {
            'name': 'openedCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('clickedCount', {
            'name': 'clickedCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('unsubscribedCount', {
            'name': 'unsubscribedCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sends', {
            'name': 'sends',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.EmailCampaignSend\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_EmailCampaignSend_relational_fields: Set[str] = {
        'campaign',
        'user',
    }
_EmailCampaignSend_fields: Dict['types.EmailCampaignSendKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('campaignId', {
            'name': 'campaignId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.EmailSendStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('sentAt', {
            'name': 'sentAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deliveredAt', {
            'name': 'deliveredAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('openedAt', {
            'name': 'openedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('clickedAt', {
            'name': 'clickedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('unsubscribedAt', {
            'name': 'unsubscribedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('bounceReason', {
            'name': 'bounceReason',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('errorMessage', {
            'name': 'errorMessage',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('campaign', {
            'name': 'campaign',
            'is_list': False,
            'optional': True,
            'type': 'models.EmailCampaign',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_EmailTemplate_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_EmailTemplate_fields: Dict['types.EmailTemplateKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('subject', {
            'name': 'subject',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('htmlContent', {
            'name': 'htmlContent',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.EmailTemplateType',
            'is_relational': False,
            'documentation': None,
        }),
        ('variables', {
            'name': 'variables',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_AutomationRules_relational_fields: Set[str] = {
        'logs',
    }
_AutomationRules_fields: Dict['types.AutomationRulesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('triggerType', {
            'name': 'triggerType',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('conditions', {
            'name': 'conditions',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('actions', {
            'name': 'actions',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastExecuted', {
            'name': 'lastExecuted',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('executionCount', {
            'name': 'executionCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('logs', {
            'name': 'logs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AutomationLogs\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_AutomationLogs_relational_fields: Set[str] = {
        'rule',
    }
_AutomationLogs_fields: Dict['types.AutomationLogsKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('ruleId', {
            'name': 'ruleId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('action', {
            'name': 'action',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('details', {
            'name': 'details',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('error', {
            'name': 'error',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('executedAt', {
            'name': 'executedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('rule', {
            'name': 'rule',
            'is_list': False,
            'optional': True,
            'type': 'models.AutomationRules',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ContentTemplates_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_ContentTemplates_fields: Dict['types.ContentTemplatesKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('template', {
            'name': 'template',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('variables', {
            'name': 'variables',
            'is_list': True,
            'optional': False,
            'type': 'List[_str]',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(History)
model_rebuild(GuideTours)
model_rebuild(Tour)
model_rebuild(TouristTours)
model_rebuild(Payment)
model_rebuild(StaffMember)
model_rebuild(Seller)
model_rebuild(Rating)
model_rebuild(ChatSession)
model_rebuild(ChatMessage)
model_rebuild(UserPreferences)
model_rebuild(AIContent)
model_rebuild(EmailCampaign)
model_rebuild(EmailCampaignSend)
model_rebuild(EmailTemplate)
model_rebuild(AutomationRules)
model_rebuild(AutomationLogs)
model_rebuild(ContentTemplates)
