# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE username = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'username': 'ggciceaie',
                'email': 'bbehjachib',
                'hash': 'cadfabfehe',
                'role': enums.Role.TOURIST,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'username': 'dgiiaaijj',
                    'email': 'bfaiacjjfc',
                    'hash': 'eigcfgbif',
                    'role': enums.Role.TOURIST,
                },
                {
                    # data to create a User record
                    'username': 'bagcfbhiig',
                    'email': 'cghideieh',
                    'hash': 'biabhbdai',
                    'role': enums.Role.TOURIST,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 836760821,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 595337866,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 790425851,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the email field
        users = await User.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the createdAt field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the hash field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'hash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 2111915288,
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 1149758321,
            },
            data={
                'create': {
                    'id': 1149758321,
                    'username': 'bagcfbhiig',
                    'email': 'cghideieh',
                    'hash': 'biabhbdai',
                    'role': enums.Role.TOURIST,
                },
                'update': {
                    'username': 'bagcfbhiig',
                    'email': 'cghideieh',
                    'hash': 'biabhbdai',
                    'role': enums.Role.TOURIST,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'hashedRt': 'bgeecijdgg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'role': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'emailSubscribed': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by emailVerified values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['emailVerified'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class HistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.History]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await History.prisma().query_raw(
            'SELECT * FROM History WHERE id = $1',
            1388290519,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.History
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await History.prisma().query_first(
            'SELECT * FROM History WHERE userId = $1',
            1647418052,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.HistoryCreateInput,
        include: Optional[types.HistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new History record.

        Parameters
        ----------
        data
            History record data
        include
            Specifies which relations should be loaded on the returned History model

        Returns
        -------
        prisma.models.History
            The created History record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a History record from just the required fields
        history = await History.prisma().create(
            data={
                # data to create a History record
                'userId': 1675546029,
                'tourId': 1767274722,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.HistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple History records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of History record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await History.prisma().create_many(
            data=[
                {
                    # data to create a History record
                    'userId': 326272115,
                    'tourId': 1343201072,
                },
                {
                    # data to create a History record
                    'userId': 675780521,
                    'tourId': 744964398,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.HistoryWhereUniqueInput,
        include: Optional[types.HistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single History record.

        Parameters
        ----------
        where
            History filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned History model

        Returns
        -------
        prisma.models.History
            The deleted History record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        history = await History.prisma().delete(
            where={
                'id': 1969681615,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.HistoryWhereUniqueInput,
        include: Optional[types.HistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique History record.

        Parameters
        ----------
        where
            History filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned History model

        Returns
        -------
        prisma.models.History
            The found History record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        history = await History.prisma().find_unique(
            where={
                'id': 1116175964,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.HistoryWhereUniqueInput,
        include: Optional[types.HistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique History record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            History filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned History model

        Returns
        -------
        prisma.models.History
            The found History record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        history = await History.prisma().find_unique_or_raise(
            where={
                'id': 861472101,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HistoryWhereInput] = None,
        cursor: Optional[types.HistoryWhereUniqueInput] = None,
        include: Optional[types.HistoryInclude] = None,
        order: Optional[Union[types.HistoryOrderByInput, List[types.HistoryOrderByInput]]] = None,
        distinct: Optional[List[types.HistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple History records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of History records returned
        skip
            Ignore the first N results
        where
            History filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned History model
        order
            Order the returned History records by any field
        distinct
            Filter History records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.History]
            The list of all History records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 History records
        historys = await History.prisma().find_many(take=10)

        # find the first 5 History records ordered by the tourId field
        historys = await History.prisma().find_many(
            take=5,
            order={
                'tourId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.HistoryWhereInput] = None,
        cursor: Optional[types.HistoryWhereUniqueInput] = None,
        include: Optional[types.HistoryInclude] = None,
        order: Optional[Union[types.HistoryOrderByInput, List[types.HistoryOrderByInput]]] = None,
        distinct: Optional[List[types.HistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single History record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            History filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned History model
        order
            Order the returned History records by any field
        distinct
            Filter History records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.History
            The first History record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second History record ordered by the viewedAt field
        history = await History.prisma().find_first(
            skip=1,
            order={
                'viewedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.HistoryWhereInput] = None,
        cursor: Optional[types.HistoryWhereUniqueInput] = None,
        include: Optional[types.HistoryInclude] = None,
        order: Optional[Union[types.HistoryOrderByInput, List[types.HistoryOrderByInput]]] = None,
        distinct: Optional[List[types.HistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single History record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            History filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned History model
        order
            Order the returned History records by any field
        distinct
            Filter History records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.History
            The first History record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second History record ordered by the interaction field
        history = await History.prisma().find_first_or_raise(
            skip=1,
            order={
                'interaction': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.HistoryUpdateInput,
        where: types.HistoryWhereUniqueInput,
        include: Optional[types.HistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single History record.

        Parameters
        ----------
        data
            History record data specifying what to update
        where
            History filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned History model

        Returns
        -------
        prisma.models.History
            The updated History record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        history = await History.prisma().update(
            where={
                'id': 1303003706,
            },
            data={
                # data to update the History record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.HistoryWhereUniqueInput,
        data: types.HistoryUpsertInput,
        include: Optional[types.HistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            History filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned History model

        Returns
        -------
        prisma.models.History
            The created or updated History record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        history = await History.prisma().upsert(
            where={
                'id': 1686638315,
            },
            data={
                'create': {
                    'id': 1686638315,
                    'userId': 675780521,
                    'tourId': 744964398,
                },
                'update': {
                    'userId': 675780521,
                    'tourId': 744964398,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.HistoryUpdateManyMutationInput,
        where: types.HistoryWhereInput,
    ) -> int:
        """Update multiple History records

        Parameters
        ----------
        data
            History data to update the selected History records to
        where
            Filter to select the History records to update

        Returns
        -------
        int
            The total number of History records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all History records
        total = await History.prisma().update_many(
            data={
                'enrolled': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HistoryWhereInput] = None,
        cursor: Optional[types.HistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of History records present in the database

        Parameters
        ----------
        select
            Select the History fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            History filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.HistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await History.prisma().count()

        # results: prisma.types.HistoryCountAggregateOutput
        results = await History.prisma().count(
            select={
                '_all': True,
                'enrolledAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.HistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HistoryWhereInput] = None,
        cursor: Optional[types.HistoryWhereUniqueInput] = None,
    ) -> types.HistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.HistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.HistoryWhereInput] = None,
        cursor: Optional[types.HistoryWhereUniqueInput] = None,
    ) -> Union[int, types.HistoryCountAggregateOutput]:
        """Count the number of History records present in the database

        Parameters
        ----------
        select
            Select the History fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            History filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.HistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await History.prisma().count()

        # results: prisma.types.HistoryCountAggregateOutput
        results = await History.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.HistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.HistoryWhereInput] = None
    ) -> int:
        """Delete multiple History records.

        Parameters
        ----------
        where
            Optional History filter to find the records to be deleted

        Returns
        -------
        int
            The total number of History records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all History records
        total = await History.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.HistoryScalarFieldKeys'],
        *,
        where: Optional['types.HistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.HistoryAvgAggregateInput'] = None,
        sum: Optional['types.HistorySumAggregateInput'] = None,
        min: Optional['types.HistoryMinAggregateInput'] = None,
        max: Optional['types.HistoryMaxAggregateInput'] = None,
        having: Optional['types.HistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.HistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.HistoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.HistoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.HistoryGroupByOutput']:
        """Group History records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar History fields to group records by
        where
            History filter to select records
        take
            Limit the maximum number of History records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.HistoryGroupByOutput]
            A list of dictionaries representing the History record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group History records by userId values
        # and count how many records are in each group
        results = await History.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class GuideToursActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.GuideTours]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await GuideTours.prisma().query_raw(
            'SELECT * FROM GuideTours WHERE id = $1',
            1868141281,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.GuideTours
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await GuideTours.prisma().query_first(
            'SELECT * FROM GuideTours WHERE guideId = $1',
            1860847622,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.GuideToursCreateInput,
        include: Optional[types.GuideToursInclude] = None
    ) -> _PrismaModelT:
        """Create a new GuideTours record.

        Parameters
        ----------
        data
            GuideTours record data
        include
            Specifies which relations should be loaded on the returned GuideTours model

        Returns
        -------
        prisma.models.GuideTours
            The created GuideTours record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a GuideTours record from just the required fields
        guidetours = await GuideTours.prisma().create(
            data={
                # data to create a GuideTours record
                'guideId': 1448521415,
                'tourId': 1628650740,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.GuideToursCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple GuideTours records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of GuideTours record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await GuideTours.prisma().create_many(
            data=[
                {
                    # data to create a GuideTours record
                    'guideId': 1249606685,
                    'tourId': 835903122,
                },
                {
                    # data to create a GuideTours record
                    'guideId': 763719779,
                    'tourId': 429995104,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.GuideToursWhereUniqueInput,
        include: Optional[types.GuideToursInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single GuideTours record.

        Parameters
        ----------
        where
            GuideTours filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned GuideTours model

        Returns
        -------
        prisma.models.GuideTours
            The deleted GuideTours record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        guidetours = await GuideTours.prisma().delete(
            where={
                'id': 1775811865,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.GuideToursWhereUniqueInput,
        include: Optional[types.GuideToursInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique GuideTours record.

        Parameters
        ----------
        where
            GuideTours filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GuideTours model

        Returns
        -------
        prisma.models.GuideTours
            The found GuideTours record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        guidetours = await GuideTours.prisma().find_unique(
            where={
                'id': 893145566,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.GuideToursWhereUniqueInput,
        include: Optional[types.GuideToursInclude] = None
    ) -> _PrismaModelT:
        """Find a unique GuideTours record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            GuideTours filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned GuideTours model

        Returns
        -------
        prisma.models.GuideTours
            The found GuideTours record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        guidetours = await GuideTours.prisma().find_unique_or_raise(
            where={
                'id': 995405759,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GuideToursWhereInput] = None,
        cursor: Optional[types.GuideToursWhereUniqueInput] = None,
        include: Optional[types.GuideToursInclude] = None,
        order: Optional[Union[types.GuideToursOrderByInput, List[types.GuideToursOrderByInput]]] = None,
        distinct: Optional[List[types.GuideToursScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple GuideTours records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of GuideTours records returned
        skip
            Ignore the first N results
        where
            GuideTours filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GuideTours model
        order
            Order the returned GuideTours records by any field
        distinct
            Filter GuideTours records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.GuideTours]
            The list of all GuideTours records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 GuideTours records
        guidetours = await GuideTours.prisma().find_many(take=10)

        # find the first 5 GuideTours records ordered by the tourId field
        guidetours = await GuideTours.prisma().find_many(
            take=5,
            order={
                'tourId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GuideToursWhereInput] = None,
        cursor: Optional[types.GuideToursWhereUniqueInput] = None,
        include: Optional[types.GuideToursInclude] = None,
        order: Optional[Union[types.GuideToursOrderByInput, List[types.GuideToursOrderByInput]]] = None,
        distinct: Optional[List[types.GuideToursScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single GuideTours record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GuideTours filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GuideTours model
        order
            Order the returned GuideTours records by any field
        distinct
            Filter GuideTours records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GuideTours
            The first GuideTours record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GuideTours record ordered by the createdAt field
        guidetours = await GuideTours.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.GuideToursWhereInput] = None,
        cursor: Optional[types.GuideToursWhereUniqueInput] = None,
        include: Optional[types.GuideToursInclude] = None,
        order: Optional[Union[types.GuideToursOrderByInput, List[types.GuideToursOrderByInput]]] = None,
        distinct: Optional[List[types.GuideToursScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single GuideTours record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            GuideTours filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned GuideTours model
        order
            Order the returned GuideTours records by any field
        distinct
            Filter GuideTours records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.GuideTours
            The first GuideTours record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second GuideTours record ordered by the updatedAt field
        guidetours = await GuideTours.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.GuideToursUpdateInput,
        where: types.GuideToursWhereUniqueInput,
        include: Optional[types.GuideToursInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single GuideTours record.

        Parameters
        ----------
        data
            GuideTours record data specifying what to update
        where
            GuideTours filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned GuideTours model

        Returns
        -------
        prisma.models.GuideTours
            The updated GuideTours record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        guidetours = await GuideTours.prisma().update(
            where={
                'id': 2102736524,
            },
            data={
                # data to update the GuideTours record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.GuideToursWhereUniqueInput,
        data: types.GuideToursUpsertInput,
        include: Optional[types.GuideToursInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            GuideTours filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned GuideTours model

        Returns
        -------
        prisma.models.GuideTours
            The created or updated GuideTours record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        guidetours = await GuideTours.prisma().upsert(
            where={
                'id': 271520213,
            },
            data={
                'create': {
                    'id': 271520213,
                    'guideId': 763719779,
                    'tourId': 429995104,
                },
                'update': {
                    'guideId': 763719779,
                    'tourId': 429995104,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.GuideToursUpdateManyMutationInput,
        where: types.GuideToursWhereInput,
    ) -> int:
        """Update multiple GuideTours records

        Parameters
        ----------
        data
            GuideTours data to update the selected GuideTours records to
        where
            Filter to select the GuideTours records to update

        Returns
        -------
        int
            The total number of GuideTours records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all GuideTours records
        total = await GuideTours.prisma().update_many(
            data={
                'id': 456633834
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GuideToursWhereInput] = None,
        cursor: Optional[types.GuideToursWhereUniqueInput] = None,
    ) -> int:
        """Count the number of GuideTours records present in the database

        Parameters
        ----------
        select
            Select the GuideTours fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GuideTours filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GuideToursCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GuideTours.prisma().count()

        # results: prisma.types.GuideToursCountAggregateOutput
        results = await GuideTours.prisma().count(
            select={
                '_all': True,
                'guideId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.GuideToursCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GuideToursWhereInput] = None,
        cursor: Optional[types.GuideToursWhereUniqueInput] = None,
    ) -> types.GuideToursCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.GuideToursCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.GuideToursWhereInput] = None,
        cursor: Optional[types.GuideToursWhereUniqueInput] = None,
    ) -> Union[int, types.GuideToursCountAggregateOutput]:
        """Count the number of GuideTours records present in the database

        Parameters
        ----------
        select
            Select the GuideTours fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            GuideTours filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.GuideToursCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await GuideTours.prisma().count()

        # results: prisma.types.GuideToursCountAggregateOutput
        results = await GuideTours.prisma().count(
            select={
                '_all': True,
                'tourId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.GuideToursCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.GuideToursWhereInput] = None
    ) -> int:
        """Delete multiple GuideTours records.

        Parameters
        ----------
        where
            Optional GuideTours filter to find the records to be deleted

        Returns
        -------
        int
            The total number of GuideTours records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all GuideTours records
        total = await GuideTours.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.GuideToursScalarFieldKeys'],
        *,
        where: Optional['types.GuideToursWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.GuideToursAvgAggregateInput'] = None,
        sum: Optional['types.GuideToursSumAggregateInput'] = None,
        min: Optional['types.GuideToursMinAggregateInput'] = None,
        max: Optional['types.GuideToursMaxAggregateInput'] = None,
        having: Optional['types.GuideToursScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.GuideToursCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.GuideToursScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.GuideToursScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.GuideToursGroupByOutput']:
        """Group GuideTours records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar GuideTours fields to group records by
        where
            GuideTours filter to select records
        take
            Limit the maximum number of GuideTours records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.GuideToursGroupByOutput]
            A list of dictionaries representing the GuideTours record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group GuideTours records by createdAt values
        # and count how many records are in each group
        results = await GuideTours.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TourActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Tour]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Tour.prisma().query_raw(
            'SELECT * FROM Tour WHERE id = $1',
            2058258651,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Tour
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Tour.prisma().query_first(
            'SELECT * FROM Tour WHERE name = $1',
            'bfidgijfjc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TourCreateInput,
        include: Optional[types.TourInclude] = None
    ) -> _PrismaModelT:
        """Create a new Tour record.

        Parameters
        ----------
        data
            Tour record data
        include
            Specifies which relations should be loaded on the returned Tour model

        Returns
        -------
        prisma.models.Tour
            The created Tour record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Tour record from just the required fields
        tour = await Tour.prisma().create(
            data={
                # data to create a Tour record
                'name': 'ihieecagf',
                'description': 'bghfciaafe',
                'price': 1627576247.205480,
                'departureDate': datetime.datetime.utcnow(),
                'returnDate': datetime.datetime.utcnow(),
                'departureLocation': 'gaddfhfh',
                'destinationLocation': 'gieegcbeg',
                'tripType': enums.TripType.STANDARD,
                'duration': 1625503827,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TourCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Tour records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Tour record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Tour.prisma().create_many(
            data=[
                {
                    # data to create a Tour record
                    'name': 'fcbichhci',
                    'description': 'bcggadccgf',
                    'price': 93253262.205304,
                    'departureDate': datetime.datetime.utcnow(),
                    'returnDate': datetime.datetime.utcnow(),
                    'departureLocation': 'gifdddbia',
                    'destinationLocation': 'bchehecef',
                    'tripType': enums.TripType.STANDARD,
                    'duration': 948921754,
                },
                {
                    # data to create a Tour record
                    'name': 'bjgejjabff',
                    'description': 'bcciijbibg',
                    'price': 255202753.122357,
                    'departureDate': datetime.datetime.utcnow(),
                    'returnDate': datetime.datetime.utcnow(),
                    'departureLocation': 'febcgjbfj',
                    'destinationLocation': 'bageiegghg',
                    'tripType': enums.TripType.STANDARD,
                    'duration': 508382461,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TourWhereUniqueInput,
        include: Optional[types.TourInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Tour record.

        Parameters
        ----------
        where
            Tour filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Tour model

        Returns
        -------
        prisma.models.Tour
            The deleted Tour record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tour = await Tour.prisma().delete(
            where={
                'id': 1024265714,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TourWhereUniqueInput,
        include: Optional[types.TourInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Tour record.

        Parameters
        ----------
        where
            Tour filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tour model

        Returns
        -------
        prisma.models.Tour
            The found Tour record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tour = await Tour.prisma().find_unique(
            where={
                'id': 872078403,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TourWhereUniqueInput,
        include: Optional[types.TourInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Tour record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Tour filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tour model

        Returns
        -------
        prisma.models.Tour
            The found Tour record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tour = await Tour.prisma().find_unique_or_raise(
            where={
                'id': 1874748096,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TourWhereInput] = None,
        cursor: Optional[types.TourWhereUniqueInput] = None,
        include: Optional[types.TourInclude] = None,
        order: Optional[Union[types.TourOrderByInput, List[types.TourOrderByInput]]] = None,
        distinct: Optional[List[types.TourScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Tour records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Tour records returned
        skip
            Ignore the first N results
        where
            Tour filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tour model
        order
            Order the returned Tour records by any field
        distinct
            Filter Tour records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Tour]
            The list of all Tour records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Tour records
        tours = await Tour.prisma().find_many(take=10)

        # find the first 5 Tour records ordered by the description field
        tours = await Tour.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TourWhereInput] = None,
        cursor: Optional[types.TourWhereUniqueInput] = None,
        include: Optional[types.TourInclude] = None,
        order: Optional[Union[types.TourOrderByInput, List[types.TourOrderByInput]]] = None,
        distinct: Optional[List[types.TourScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Tour record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tour filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tour model
        order
            Order the returned Tour records by any field
        distinct
            Filter Tour records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tour
            The first Tour record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tour record ordered by the price field
        tour = await Tour.prisma().find_first(
            skip=1,
            order={
                'price': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TourWhereInput] = None,
        cursor: Optional[types.TourWhereUniqueInput] = None,
        include: Optional[types.TourInclude] = None,
        order: Optional[Union[types.TourOrderByInput, List[types.TourOrderByInput]]] = None,
        distinct: Optional[List[types.TourScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Tour record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tour filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tour model
        order
            Order the returned Tour records by any field
        distinct
            Filter Tour records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tour
            The first Tour record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tour record ordered by the departureDate field
        tour = await Tour.prisma().find_first_or_raise(
            skip=1,
            order={
                'departureDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TourUpdateInput,
        where: types.TourWhereUniqueInput,
        include: Optional[types.TourInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Tour record.

        Parameters
        ----------
        data
            Tour record data specifying what to update
        where
            Tour filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Tour model

        Returns
        -------
        prisma.models.Tour
            The updated Tour record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tour = await Tour.prisma().update(
            where={
                'id': 916896761,
            },
            data={
                # data to update the Tour record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TourWhereUniqueInput,
        data: types.TourUpsertInput,
        include: Optional[types.TourInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Tour filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Tour model

        Returns
        -------
        prisma.models.Tour
            The created or updated Tour record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tour = await Tour.prisma().upsert(
            where={
                'id': 769267518,
            },
            data={
                'create': {
                    'id': 769267518,
                    'name': 'bjgejjabff',
                    'description': 'bcciijbibg',
                    'price': 255202753.122357,
                    'departureDate': datetime.datetime.utcnow(),
                    'returnDate': datetime.datetime.utcnow(),
                    'departureLocation': 'febcgjbfj',
                    'destinationLocation': 'bageiegghg',
                    'tripType': enums.TripType.STANDARD,
                    'duration': 508382461,
                },
                'update': {
                    'name': 'bjgejjabff',
                    'description': 'bcciijbibg',
                    'price': 255202753.122357,
                    'departureDate': datetime.datetime.utcnow(),
                    'returnDate': datetime.datetime.utcnow(),
                    'departureLocation': 'febcgjbfj',
                    'destinationLocation': 'bageiegghg',
                    'tripType': enums.TripType.STANDARD,
                    'duration': 508382461,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TourUpdateManyMutationInput,
        where: types.TourWhereInput,
    ) -> int:
        """Update multiple Tour records

        Parameters
        ----------
        data
            Tour data to update the selected Tour records to
        where
            Filter to select the Tour records to update

        Returns
        -------
        int
            The total number of Tour records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Tour records
        total = await Tour.prisma().update_many(
            data={
                'returnDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TourWhereInput] = None,
        cursor: Optional[types.TourWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Tour records present in the database

        Parameters
        ----------
        select
            Select the Tour fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tour filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TourCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tour.prisma().count()

        # results: prisma.types.TourCountAggregateOutput
        results = await Tour.prisma().count(
            select={
                '_all': True,
                'departureLocation': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TourCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TourWhereInput] = None,
        cursor: Optional[types.TourWhereUniqueInput] = None,
    ) -> types.TourCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TourCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TourWhereInput] = None,
        cursor: Optional[types.TourWhereUniqueInput] = None,
    ) -> Union[int, types.TourCountAggregateOutput]:
        """Count the number of Tour records present in the database

        Parameters
        ----------
        select
            Select the Tour fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tour filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TourCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tour.prisma().count()

        # results: prisma.types.TourCountAggregateOutput
        results = await Tour.prisma().count(
            select={
                '_all': True,
                'destinationLocation': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TourCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TourWhereInput] = None
    ) -> int:
        """Delete multiple Tour records.

        Parameters
        ----------
        where
            Optional Tour filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Tour records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Tour records
        total = await Tour.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TourScalarFieldKeys'],
        *,
        where: Optional['types.TourWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TourAvgAggregateInput'] = None,
        sum: Optional['types.TourSumAggregateInput'] = None,
        min: Optional['types.TourMinAggregateInput'] = None,
        max: Optional['types.TourMaxAggregateInput'] = None,
        having: Optional['types.TourScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TourCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TourScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TourScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TourGroupByOutput']:
        """Group Tour records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Tour fields to group records by
        where
            Tour filter to select records
        take
            Limit the maximum number of Tour records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TourGroupByOutput]
            A list of dictionaries representing the Tour record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Tour records by includedFeatures values
        # and count how many records are in each group
        results = await Tour.prisma().group_by(
            ['includedFeatures'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TouristToursActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TouristTours]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TouristTours.prisma().query_raw(
            'SELECT * FROM TouristTours WHERE id = $1',
            820312479,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TouristTours
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TouristTours.prisma().query_first(
            'SELECT * FROM TouristTours WHERE touristId = $1',
            92728044,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TouristToursCreateInput,
        include: Optional[types.TouristToursInclude] = None
    ) -> _PrismaModelT:
        """Create a new TouristTours record.

        Parameters
        ----------
        data
            TouristTours record data
        include
            Specifies which relations should be loaded on the returned TouristTours model

        Returns
        -------
        prisma.models.TouristTours
            The created TouristTours record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TouristTours record from just the required fields
        touristtours = await TouristTours.prisma().create(
            data={
                # data to create a TouristTours record
                'touristId': 344858293,
                'tourId': 1121741130,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TouristToursCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TouristTours records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TouristTours record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TouristTours.prisma().create_many(
            data=[
                {
                    # data to create a TouristTours record
                    'touristId': 1495896251,
                    'tourId': 208521688,
                },
                {
                    # data to create a TouristTours record
                    'touristId': 860811569,
                    'tourId': 1660932118,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TouristToursWhereUniqueInput,
        include: Optional[types.TouristToursInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TouristTours record.

        Parameters
        ----------
        where
            TouristTours filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TouristTours model

        Returns
        -------
        prisma.models.TouristTours
            The deleted TouristTours record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        touristtours = await TouristTours.prisma().delete(
            where={
                'id': 525761943,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TouristToursWhereUniqueInput,
        include: Optional[types.TouristToursInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TouristTours record.

        Parameters
        ----------
        where
            TouristTours filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TouristTours model

        Returns
        -------
        prisma.models.TouristTours
            The found TouristTours record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        touristtours = await TouristTours.prisma().find_unique(
            where={
                'id': 736209796,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TouristToursWhereUniqueInput,
        include: Optional[types.TouristToursInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TouristTours record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TouristTours filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TouristTours model

        Returns
        -------
        prisma.models.TouristTours
            The found TouristTours record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        touristtours = await TouristTours.prisma().find_unique_or_raise(
            where={
                'id': 493907821,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TouristToursWhereInput] = None,
        cursor: Optional[types.TouristToursWhereUniqueInput] = None,
        include: Optional[types.TouristToursInclude] = None,
        order: Optional[Union[types.TouristToursOrderByInput, List[types.TouristToursOrderByInput]]] = None,
        distinct: Optional[List[types.TouristToursScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TouristTours records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TouristTours records returned
        skip
            Ignore the first N results
        where
            TouristTours filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TouristTours model
        order
            Order the returned TouristTours records by any field
        distinct
            Filter TouristTours records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TouristTours]
            The list of all TouristTours records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TouristTours records
        touristtours = await TouristTours.prisma().find_many(take=10)

        # find the first 5 TouristTours records ordered by the tourId field
        touristtours = await TouristTours.prisma().find_many(
            take=5,
            order={
                'tourId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TouristToursWhereInput] = None,
        cursor: Optional[types.TouristToursWhereUniqueInput] = None,
        include: Optional[types.TouristToursInclude] = None,
        order: Optional[Union[types.TouristToursOrderByInput, List[types.TouristToursOrderByInput]]] = None,
        distinct: Optional[List[types.TouristToursScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TouristTours record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TouristTours filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TouristTours model
        order
            Order the returned TouristTours records by any field
        distinct
            Filter TouristTours records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TouristTours
            The first TouristTours record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TouristTours record ordered by the status field
        touristtours = await TouristTours.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TouristToursWhereInput] = None,
        cursor: Optional[types.TouristToursWhereUniqueInput] = None,
        include: Optional[types.TouristToursInclude] = None,
        order: Optional[Union[types.TouristToursOrderByInput, List[types.TouristToursOrderByInput]]] = None,
        distinct: Optional[List[types.TouristToursScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TouristTours record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TouristTours filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TouristTours model
        order
            Order the returned TouristTours records by any field
        distinct
            Filter TouristTours records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TouristTours
            The first TouristTours record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TouristTours record ordered by the id field
        touristtours = await TouristTours.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TouristToursUpdateInput,
        where: types.TouristToursWhereUniqueInput,
        include: Optional[types.TouristToursInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TouristTours record.

        Parameters
        ----------
        data
            TouristTours record data specifying what to update
        where
            TouristTours filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TouristTours model

        Returns
        -------
        prisma.models.TouristTours
            The updated TouristTours record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        touristtours = await TouristTours.prisma().update(
            where={
                'id': 639686562,
            },
            data={
                # data to update the TouristTours record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TouristToursWhereUniqueInput,
        data: types.TouristToursUpsertInput,
        include: Optional[types.TouristToursInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TouristTours filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TouristTours model

        Returns
        -------
        prisma.models.TouristTours
            The created or updated TouristTours record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        touristtours = await TouristTours.prisma().upsert(
            where={
                'id': 654007347,
            },
            data={
                'create': {
                    'id': 654007347,
                    'touristId': 860811569,
                    'tourId': 1660932118,
                },
                'update': {
                    'touristId': 860811569,
                    'tourId': 1660932118,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TouristToursUpdateManyMutationInput,
        where: types.TouristToursWhereInput,
    ) -> int:
        """Update multiple TouristTours records

        Parameters
        ----------
        data
            TouristTours data to update the selected TouristTours records to
        where
            Filter to select the TouristTours records to update

        Returns
        -------
        int
            The total number of TouristTours records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TouristTours records
        total = await TouristTours.prisma().update_many(
            data={
                'touristId': 1905261552
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TouristToursWhereInput] = None,
        cursor: Optional[types.TouristToursWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TouristTours records present in the database

        Parameters
        ----------
        select
            Select the TouristTours fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TouristTours filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TouristToursCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TouristTours.prisma().count()

        # results: prisma.types.TouristToursCountAggregateOutput
        results = await TouristTours.prisma().count(
            select={
                '_all': True,
                'tourId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TouristToursCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TouristToursWhereInput] = None,
        cursor: Optional[types.TouristToursWhereUniqueInput] = None,
    ) -> types.TouristToursCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TouristToursCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TouristToursWhereInput] = None,
        cursor: Optional[types.TouristToursWhereUniqueInput] = None,
    ) -> Union[int, types.TouristToursCountAggregateOutput]:
        """Count the number of TouristTours records present in the database

        Parameters
        ----------
        select
            Select the TouristTours fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TouristTours filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TouristToursCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TouristTours.prisma().count()

        # results: prisma.types.TouristToursCountAggregateOutput
        results = await TouristTours.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TouristToursCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TouristToursWhereInput] = None
    ) -> int:
        """Delete multiple TouristTours records.

        Parameters
        ----------
        where
            Optional TouristTours filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TouristTours records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TouristTours records
        total = await TouristTours.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TouristToursScalarFieldKeys'],
        *,
        where: Optional['types.TouristToursWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TouristToursAvgAggregateInput'] = None,
        sum: Optional['types.TouristToursSumAggregateInput'] = None,
        min: Optional['types.TouristToursMinAggregateInput'] = None,
        max: Optional['types.TouristToursMaxAggregateInput'] = None,
        having: Optional['types.TouristToursScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TouristToursCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TouristToursScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TouristToursScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TouristToursGroupByOutput']:
        """Group TouristTours records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TouristTours fields to group records by
        where
            TouristTours filter to select records
        take
            Limit the maximum number of TouristTours records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TouristToursGroupByOutput]
            A list of dictionaries representing the TouristTours record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TouristTours records by id values
        # and count how many records are in each group
        results = await TouristTours.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PaymentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Payment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Payment.prisma().query_raw(
            'SELECT * FROM Payment WHERE id = $1',
            78746985,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Payment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Payment.prisma().query_first(
            'SELECT * FROM Payment WHERE userId = $1',
            1398328302,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PaymentCreateInput,
        include: Optional[types.PaymentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Payment record.

        Parameters
        ----------
        data
            Payment record data
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The created Payment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Payment record from just the required fields
        payment = await Payment.prisma().create(
            data={
                # data to create a Payment record
                'userId': 856000655,
                'tourId': 1452336924,
                'amount': 1573199653.201390,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PaymentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Payment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Payment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Payment.prisma().create_many(
            data=[
                {
                    # data to create a Payment record
                    'userId': 500965035,
                    'tourId': 1800624392,
                    'amount': 2077067425.167211,
                },
                {
                    # data to create a Payment record
                    'userId': 926677639,
                    'tourId': 1447624116,
                    'amount': 1738083805.34094,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Payment record.

        Parameters
        ----------
        where
            Payment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The deleted Payment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().delete(
            where={
                'id': 601077795,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Payment record.

        Parameters
        ----------
        where
            Payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The found Payment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().find_unique(
            where={
                'id': 290603296,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Payment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Payment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The found Payment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().find_unique_or_raise(
            where={
                'id': 1855826649,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Payment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Payment records returned
        skip
            Ignore the first N results
        where
            Payment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Payment]
            The list of all Payment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Payment records
        payments = await Payment.prisma().find_many(take=10)

        # find the first 5 Payment records ordered by the tourId field
        payments = await Payment.prisma().find_many(
            take=5,
            order={
                'tourId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Payment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Payment
            The first Payment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Payment record ordered by the amount field
        payment = await Payment.prisma().find_first(
            skip=1,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
        include: Optional[types.PaymentInclude] = None,
        order: Optional[Union[types.PaymentOrderByInput, List[types.PaymentOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Payment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Payment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Payment model
        order
            Order the returned Payment records by any field
        distinct
            Filter Payment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Payment
            The first Payment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Payment record ordered by the numberOfPeople field
        payment = await Payment.prisma().find_first_or_raise(
            skip=1,
            order={
                'numberOfPeople': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PaymentUpdateInput,
        where: types.PaymentWhereUniqueInput,
        include: Optional[types.PaymentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Payment record.

        Parameters
        ----------
        data
            Payment record data specifying what to update
        where
            Payment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The updated Payment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        payment = await Payment.prisma().update(
            where={
                'id': 1611009182,
            },
            data={
                # data to update the Payment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PaymentWhereUniqueInput,
        data: types.PaymentUpsertInput,
        include: Optional[types.PaymentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Payment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Payment model

        Returns
        -------
        prisma.models.Payment
            The created or updated Payment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        payment = await Payment.prisma().upsert(
            where={
                'id': 446673791,
            },
            data={
                'create': {
                    'id': 446673791,
                    'userId': 926677639,
                    'tourId': 1447624116,
                    'amount': 1738083805.34094,
                },
                'update': {
                    'userId': 926677639,
                    'tourId': 1447624116,
                    'amount': 1738083805.34094,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PaymentUpdateManyMutationInput,
        where: types.PaymentWhereInput,
    ) -> int:
        """Update multiple Payment records

        Parameters
        ----------
        data
            Payment data to update the selected Payment records to
        where
            Filter to select the Payment records to update

        Returns
        -------
        int
            The total number of Payment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Payment records
        total = await Payment.prisma().update_many(
            data={
                'currency': 'daafgidjg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Payment records present in the database

        Parameters
        ----------
        select
            Select the Payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Payment.prisma().count()

        # results: prisma.types.PaymentCountAggregateOutput
        results = await Payment.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PaymentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> types.PaymentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PaymentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentWhereInput] = None,
        cursor: Optional[types.PaymentWhereUniqueInput] = None,
    ) -> Union[int, types.PaymentCountAggregateOutput]:
        """Count the number of Payment records present in the database

        Parameters
        ----------
        select
            Select the Payment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Payment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Payment.prisma().count()

        # results: prisma.types.PaymentCountAggregateOutput
        results = await Payment.prisma().count(
            select={
                '_all': True,
                'transactionId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PaymentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PaymentWhereInput] = None
    ) -> int:
        """Delete multiple Payment records.

        Parameters
        ----------
        where
            Optional Payment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Payment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Payment records
        total = await Payment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PaymentScalarFieldKeys'],
        *,
        where: Optional['types.PaymentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PaymentAvgAggregateInput'] = None,
        sum: Optional['types.PaymentSumAggregateInput'] = None,
        min: Optional['types.PaymentMinAggregateInput'] = None,
        max: Optional['types.PaymentMaxAggregateInput'] = None,
        having: Optional['types.PaymentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PaymentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PaymentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PaymentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PaymentGroupByOutput']:
        """Group Payment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Payment fields to group records by
        where
            Payment filter to select records
        take
            Limit the maximum number of Payment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PaymentGroupByOutput]
            A list of dictionaries representing the Payment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Payment records by gatewayResponse values
        # and count how many records are in each group
        results = await Payment.prisma().group_by(
            ['gatewayResponse'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class StaffMemberActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.StaffMember]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await StaffMember.prisma().query_raw(
            'SELECT * FROM StaffMember WHERE id = $1',
            632626069,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.StaffMember
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await StaffMember.prisma().query_first(
            'SELECT * FROM StaffMember WHERE name = $1',
            'bhceabbgja',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.StaffMemberCreateInput,
        include: Optional[types.StaffMemberInclude] = None
    ) -> _PrismaModelT:
        """Create a new StaffMember record.

        Parameters
        ----------
        data
            StaffMember record data
        include
            Specifies which relations should be loaded on the returned StaffMember model

        Returns
        -------
        prisma.models.StaffMember
            The created StaffMember record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a StaffMember record from just the required fields
        staffmember = await StaffMember.prisma().create(
            data={
                # data to create a StaffMember record
                'name': 'ehabfhegh',
                'email': 'bcajcajjbc',
                'password': 'bfdgheeegf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.StaffMemberCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple StaffMember records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of StaffMember record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await StaffMember.prisma().create_many(
            data=[
                {
                    # data to create a StaffMember record
                    'name': 'ececbijji',
                    'email': 'cbcfgdcdhf',
                    'password': 'fdgjfbhia',
                },
                {
                    # data to create a StaffMember record
                    'name': 'jcehcdchh',
                    'email': 'bgcbjdhjcc',
                    'password': 'bieiidcabj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.StaffMemberWhereUniqueInput,
        include: Optional[types.StaffMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single StaffMember record.

        Parameters
        ----------
        where
            StaffMember filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned StaffMember model

        Returns
        -------
        prisma.models.StaffMember
            The deleted StaffMember record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        staffmember = await StaffMember.prisma().delete(
            where={
                'id': 1921528400,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.StaffMemberWhereUniqueInput,
        include: Optional[types.StaffMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique StaffMember record.

        Parameters
        ----------
        where
            StaffMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned StaffMember model

        Returns
        -------
        prisma.models.StaffMember
            The found StaffMember record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        staffmember = await StaffMember.prisma().find_unique(
            where={
                'id': 2100427849,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.StaffMemberWhereUniqueInput,
        include: Optional[types.StaffMemberInclude] = None
    ) -> _PrismaModelT:
        """Find a unique StaffMember record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            StaffMember filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned StaffMember model

        Returns
        -------
        prisma.models.StaffMember
            The found StaffMember record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        staffmember = await StaffMember.prisma().find_unique_or_raise(
            where={
                'id': 849140046,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StaffMemberWhereInput] = None,
        cursor: Optional[types.StaffMemberWhereUniqueInput] = None,
        include: Optional[types.StaffMemberInclude] = None,
        order: Optional[Union[types.StaffMemberOrderByInput, List[types.StaffMemberOrderByInput]]] = None,
        distinct: Optional[List[types.StaffMemberScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple StaffMember records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of StaffMember records returned
        skip
            Ignore the first N results
        where
            StaffMember filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StaffMember model
        order
            Order the returned StaffMember records by any field
        distinct
            Filter StaffMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.StaffMember]
            The list of all StaffMember records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 StaffMember records
        staffmembers = await StaffMember.prisma().find_many(take=10)

        # find the first 5 StaffMember records ordered by the email field
        staffmembers = await StaffMember.prisma().find_many(
            take=5,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StaffMemberWhereInput] = None,
        cursor: Optional[types.StaffMemberWhereUniqueInput] = None,
        include: Optional[types.StaffMemberInclude] = None,
        order: Optional[Union[types.StaffMemberOrderByInput, List[types.StaffMemberOrderByInput]]] = None,
        distinct: Optional[List[types.StaffMemberScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single StaffMember record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            StaffMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StaffMember model
        order
            Order the returned StaffMember records by any field
        distinct
            Filter StaffMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.StaffMember
            The first StaffMember record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second StaffMember record ordered by the password field
        staffmember = await StaffMember.prisma().find_first(
            skip=1,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.StaffMemberWhereInput] = None,
        cursor: Optional[types.StaffMemberWhereUniqueInput] = None,
        include: Optional[types.StaffMemberInclude] = None,
        order: Optional[Union[types.StaffMemberOrderByInput, List[types.StaffMemberOrderByInput]]] = None,
        distinct: Optional[List[types.StaffMemberScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single StaffMember record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            StaffMember filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned StaffMember model
        order
            Order the returned StaffMember records by any field
        distinct
            Filter StaffMember records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.StaffMember
            The first StaffMember record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second StaffMember record ordered by the id field
        staffmember = await StaffMember.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.StaffMemberUpdateInput,
        where: types.StaffMemberWhereUniqueInput,
        include: Optional[types.StaffMemberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single StaffMember record.

        Parameters
        ----------
        data
            StaffMember record data specifying what to update
        where
            StaffMember filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned StaffMember model

        Returns
        -------
        prisma.models.StaffMember
            The updated StaffMember record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        staffmember = await StaffMember.prisma().update(
            where={
                'id': 928152175,
            },
            data={
                # data to update the StaffMember record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.StaffMemberWhereUniqueInput,
        data: types.StaffMemberUpsertInput,
        include: Optional[types.StaffMemberInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            StaffMember filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned StaffMember model

        Returns
        -------
        prisma.models.StaffMember
            The created or updated StaffMember record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        staffmember = await StaffMember.prisma().upsert(
            where={
                'id': 273032060,
            },
            data={
                'create': {
                    'id': 273032060,
                    'name': 'jcehcdchh',
                    'email': 'bgcbjdhjcc',
                    'password': 'bieiidcabj',
                },
                'update': {
                    'name': 'jcehcdchh',
                    'email': 'bgcbjdhjcc',
                    'password': 'bieiidcabj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.StaffMemberUpdateManyMutationInput,
        where: types.StaffMemberWhereInput,
    ) -> int:
        """Update multiple StaffMember records

        Parameters
        ----------
        data
            StaffMember data to update the selected StaffMember records to
        where
            Filter to select the StaffMember records to update

        Returns
        -------
        int
            The total number of StaffMember records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all StaffMember records
        total = await StaffMember.prisma().update_many(
            data={
                'name': 'jicieifbh'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StaffMemberWhereInput] = None,
        cursor: Optional[types.StaffMemberWhereUniqueInput] = None,
    ) -> int:
        """Count the number of StaffMember records present in the database

        Parameters
        ----------
        select
            Select the StaffMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            StaffMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StaffMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await StaffMember.prisma().count()

        # results: prisma.types.StaffMemberCountAggregateOutput
        results = await StaffMember.prisma().count(
            select={
                '_all': True,
                'email': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.StaffMemberCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StaffMemberWhereInput] = None,
        cursor: Optional[types.StaffMemberWhereUniqueInput] = None,
    ) -> types.StaffMemberCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.StaffMemberCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.StaffMemberWhereInput] = None,
        cursor: Optional[types.StaffMemberWhereUniqueInput] = None,
    ) -> Union[int, types.StaffMemberCountAggregateOutput]:
        """Count the number of StaffMember records present in the database

        Parameters
        ----------
        select
            Select the StaffMember fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            StaffMember filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.StaffMemberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await StaffMember.prisma().count()

        # results: prisma.types.StaffMemberCountAggregateOutput
        results = await StaffMember.prisma().count(
            select={
                '_all': True,
                'password': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.StaffMemberCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.StaffMemberWhereInput] = None
    ) -> int:
        """Delete multiple StaffMember records.

        Parameters
        ----------
        where
            Optional StaffMember filter to find the records to be deleted

        Returns
        -------
        int
            The total number of StaffMember records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all StaffMember records
        total = await StaffMember.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.StaffMemberScalarFieldKeys'],
        *,
        where: Optional['types.StaffMemberWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.StaffMemberAvgAggregateInput'] = None,
        sum: Optional['types.StaffMemberSumAggregateInput'] = None,
        min: Optional['types.StaffMemberMinAggregateInput'] = None,
        max: Optional['types.StaffMemberMaxAggregateInput'] = None,
        having: Optional['types.StaffMemberScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.StaffMemberCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.StaffMemberScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.StaffMemberScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.StaffMemberGroupByOutput']:
        """Group StaffMember records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar StaffMember fields to group records by
        where
            StaffMember filter to select records
        take
            Limit the maximum number of StaffMember records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.StaffMemberGroupByOutput]
            A list of dictionaries representing the StaffMember record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group StaffMember records by id values
        # and count how many records are in each group
        results = await StaffMember.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SellerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Seller]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Seller.prisma().query_raw(
            'SELECT * FROM Seller WHERE id = $1',
            510737498,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Seller
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Seller.prisma().query_first(
            'SELECT * FROM Seller WHERE StaffMemberId = $1',
            2117488267,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SellerCreateInput,
        include: Optional[types.SellerInclude] = None
    ) -> _PrismaModelT:
        """Create a new Seller record.

        Parameters
        ----------
        data
            Seller record data
        include
            Specifies which relations should be loaded on the returned Seller model

        Returns
        -------
        prisma.models.Seller
            The created Seller record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Seller record from just the required fields
        seller = await Seller.prisma().create(
            data={
                # data to create a Seller record
                'StaffMemberId': 1401944936,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SellerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Seller records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Seller record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Seller.prisma().create_many(
            data=[
                {
                    # data to create a Seller record
                    'StaffMemberId': 1297607553,
                },
                {
                    # data to create a Seller record
                    'StaffMemberId': 519488550,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SellerWhereUniqueInput,
        include: Optional[types.SellerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Seller record.

        Parameters
        ----------
        where
            Seller filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Seller model

        Returns
        -------
        prisma.models.Seller
            The deleted Seller record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        seller = await Seller.prisma().delete(
            where={
                'id': 976832615,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SellerWhereUniqueInput,
        include: Optional[types.SellerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Seller record.

        Parameters
        ----------
        where
            Seller filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Seller model

        Returns
        -------
        prisma.models.Seller
            The found Seller record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        seller = await Seller.prisma().find_unique(
            where={
                'id': 1696425492,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SellerWhereUniqueInput,
        include: Optional[types.SellerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Seller record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Seller filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Seller model

        Returns
        -------
        prisma.models.Seller
            The found Seller record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        seller = await Seller.prisma().find_unique_or_raise(
            where={
                'id': 169262781,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SellerWhereInput] = None,
        cursor: Optional[types.SellerWhereUniqueInput] = None,
        include: Optional[types.SellerInclude] = None,
        order: Optional[Union[types.SellerOrderByInput, List[types.SellerOrderByInput]]] = None,
        distinct: Optional[List[types.SellerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Seller records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Seller records returned
        skip
            Ignore the first N results
        where
            Seller filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Seller model
        order
            Order the returned Seller records by any field
        distinct
            Filter Seller records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Seller]
            The list of all Seller records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Seller records
        sellers = await Seller.prisma().find_many(take=10)

        # find the first 5 Seller records ordered by the id field
        sellers = await Seller.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SellerWhereInput] = None,
        cursor: Optional[types.SellerWhereUniqueInput] = None,
        include: Optional[types.SellerInclude] = None,
        order: Optional[Union[types.SellerOrderByInput, List[types.SellerOrderByInput]]] = None,
        distinct: Optional[List[types.SellerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Seller record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Seller filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Seller model
        order
            Order the returned Seller records by any field
        distinct
            Filter Seller records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Seller
            The first Seller record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Seller record ordered by the StaffMemberId field
        seller = await Seller.prisma().find_first(
            skip=1,
            order={
                'StaffMemberId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SellerWhereInput] = None,
        cursor: Optional[types.SellerWhereUniqueInput] = None,
        include: Optional[types.SellerInclude] = None,
        order: Optional[Union[types.SellerOrderByInput, List[types.SellerOrderByInput]]] = None,
        distinct: Optional[List[types.SellerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Seller record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Seller filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Seller model
        order
            Order the returned Seller records by any field
        distinct
            Filter Seller records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Seller
            The first Seller record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Seller record ordered by the id field
        seller = await Seller.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SellerUpdateInput,
        where: types.SellerWhereUniqueInput,
        include: Optional[types.SellerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Seller record.

        Parameters
        ----------
        data
            Seller record data specifying what to update
        where
            Seller filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Seller model

        Returns
        -------
        prisma.models.Seller
            The updated Seller record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        seller = await Seller.prisma().update(
            where={
                'id': 1023081650,
            },
            data={
                # data to update the Seller record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SellerWhereUniqueInput,
        data: types.SellerUpsertInput,
        include: Optional[types.SellerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Seller filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Seller model

        Returns
        -------
        prisma.models.Seller
            The created or updated Seller record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        seller = await Seller.prisma().upsert(
            where={
                'id': 327681027,
            },
            data={
                'create': {
                    'id': 327681027,
                    'StaffMemberId': 519488550,
                },
                'update': {
                    'StaffMemberId': 519488550,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SellerUpdateManyMutationInput,
        where: types.SellerWhereInput,
    ) -> int:
        """Update multiple Seller records

        Parameters
        ----------
        data
            Seller data to update the selected Seller records to
        where
            Filter to select the Seller records to update

        Returns
        -------
        int
            The total number of Seller records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Seller records
        total = await Seller.prisma().update_many(
            data={
                'StaffMemberId': 527748992
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SellerWhereInput] = None,
        cursor: Optional[types.SellerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Seller records present in the database

        Parameters
        ----------
        select
            Select the Seller fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Seller filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SellerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Seller.prisma().count()

        # results: prisma.types.SellerCountAggregateOutput
        results = await Seller.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SellerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SellerWhereInput] = None,
        cursor: Optional[types.SellerWhereUniqueInput] = None,
    ) -> types.SellerCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SellerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SellerWhereInput] = None,
        cursor: Optional[types.SellerWhereUniqueInput] = None,
    ) -> Union[int, types.SellerCountAggregateOutput]:
        """Count the number of Seller records present in the database

        Parameters
        ----------
        select
            Select the Seller fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Seller filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SellerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Seller.prisma().count()

        # results: prisma.types.SellerCountAggregateOutput
        results = await Seller.prisma().count(
            select={
                '_all': True,
                'StaffMemberId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SellerCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SellerWhereInput] = None
    ) -> int:
        """Delete multiple Seller records.

        Parameters
        ----------
        where
            Optional Seller filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Seller records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Seller records
        total = await Seller.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SellerScalarFieldKeys'],
        *,
        where: Optional['types.SellerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SellerAvgAggregateInput'] = None,
        sum: Optional['types.SellerSumAggregateInput'] = None,
        min: Optional['types.SellerMinAggregateInput'] = None,
        max: Optional['types.SellerMaxAggregateInput'] = None,
        having: Optional['types.SellerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SellerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SellerScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SellerScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SellerGroupByOutput']:
        """Group Seller records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Seller fields to group records by
        where
            Seller filter to select records
        take
            Limit the maximum number of Seller records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SellerGroupByOutput]
            A list of dictionaries representing the Seller record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Seller records by id values
        # and count how many records are in each group
        results = await Seller.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RatingActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Rating]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Rating.prisma().query_raw(
            'SELECT * FROM Rating WHERE id = $1',
            2029357497,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Rating
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Rating.prisma().query_first(
            'SELECT * FROM Rating WHERE rating = $1',
            1318597118,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RatingCreateInput,
        include: Optional[types.RatingInclude] = None
    ) -> _PrismaModelT:
        """Create a new Rating record.

        Parameters
        ----------
        data
            Rating record data
        include
            Specifies which relations should be loaded on the returned Rating model

        Returns
        -------
        prisma.models.Rating
            The created Rating record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Rating record from just the required fields
        rating = await Rating.prisma().create(
            data={
                # data to create a Rating record
                'rating': 2122112351,
                'userId': 1024943020,
                'tourId': 1717307509,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RatingCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Rating records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Rating record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Rating.prisma().create_many(
            data=[
                {
                    # data to create a Rating record
                    'rating': 1598124042,
                    'userId': 817623163,
                    'tourId': 1030557336,
                },
                {
                    # data to create a Rating record
                    'rating': 1131525873,
                    'userId': 210666198,
                    'tourId': 1276057943,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RatingWhereUniqueInput,
        include: Optional[types.RatingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Rating record.

        Parameters
        ----------
        where
            Rating filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Rating model

        Returns
        -------
        prisma.models.Rating
            The deleted Rating record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating = await Rating.prisma().delete(
            where={
                'id': 745569348,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RatingWhereUniqueInput,
        include: Optional[types.RatingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Rating record.

        Parameters
        ----------
        where
            Rating filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Rating model

        Returns
        -------
        prisma.models.Rating
            The found Rating record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating = await Rating.prisma().find_unique(
            where={
                'id': 307876141,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RatingWhereUniqueInput,
        include: Optional[types.RatingInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Rating record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Rating filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Rating model

        Returns
        -------
        prisma.models.Rating
            The found Rating record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating = await Rating.prisma().find_unique_or_raise(
            where={
                'id': 1674049122,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RatingWhereInput] = None,
        cursor: Optional[types.RatingWhereUniqueInput] = None,
        include: Optional[types.RatingInclude] = None,
        order: Optional[Union[types.RatingOrderByInput, List[types.RatingOrderByInput]]] = None,
        distinct: Optional[List[types.RatingScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Rating records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Rating records returned
        skip
            Ignore the first N results
        where
            Rating filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Rating model
        order
            Order the returned Rating records by any field
        distinct
            Filter Rating records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Rating]
            The list of all Rating records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Rating records
        ratings = await Rating.prisma().find_many(take=10)

        # find the first 5 Rating records ordered by the review field
        ratings = await Rating.prisma().find_many(
            take=5,
            order={
                'review': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RatingWhereInput] = None,
        cursor: Optional[types.RatingWhereUniqueInput] = None,
        include: Optional[types.RatingInclude] = None,
        order: Optional[Union[types.RatingOrderByInput, List[types.RatingOrderByInput]]] = None,
        distinct: Optional[List[types.RatingScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Rating record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Rating filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Rating model
        order
            Order the returned Rating records by any field
        distinct
            Filter Rating records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Rating
            The first Rating record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Rating record ordered by the userId field
        rating = await Rating.prisma().find_first(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RatingWhereInput] = None,
        cursor: Optional[types.RatingWhereUniqueInput] = None,
        include: Optional[types.RatingInclude] = None,
        order: Optional[Union[types.RatingOrderByInput, List[types.RatingOrderByInput]]] = None,
        distinct: Optional[List[types.RatingScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Rating record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Rating filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Rating model
        order
            Order the returned Rating records by any field
        distinct
            Filter Rating records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Rating
            The first Rating record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Rating record ordered by the tourId field
        rating = await Rating.prisma().find_first_or_raise(
            skip=1,
            order={
                'tourId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RatingUpdateInput,
        where: types.RatingWhereUniqueInput,
        include: Optional[types.RatingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Rating record.

        Parameters
        ----------
        data
            Rating record data specifying what to update
        where
            Rating filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Rating model

        Returns
        -------
        prisma.models.Rating
            The updated Rating record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        rating = await Rating.prisma().update(
            where={
                'id': 1526854643,
            },
            data={
                # data to update the Rating record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RatingWhereUniqueInput,
        data: types.RatingUpsertInput,
        include: Optional[types.RatingInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Rating filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Rating model

        Returns
        -------
        prisma.models.Rating
            The created or updated Rating record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating = await Rating.prisma().upsert(
            where={
                'id': 958077104,
            },
            data={
                'create': {
                    'id': 958077104,
                    'rating': 1131525873,
                    'userId': 210666198,
                    'tourId': 1276057943,
                },
                'update': {
                    'rating': 1131525873,
                    'userId': 210666198,
                    'tourId': 1276057943,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RatingUpdateManyMutationInput,
        where: types.RatingWhereInput,
    ) -> int:
        """Update multiple Rating records

        Parameters
        ----------
        data
            Rating data to update the selected Rating records to
        where
            Filter to select the Rating records to update

        Returns
        -------
        int
            The total number of Rating records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Rating records
        total = await Rating.prisma().update_many(
            data={
                'id': 1513050921
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RatingWhereInput] = None,
        cursor: Optional[types.RatingWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Rating records present in the database

        Parameters
        ----------
        select
            Select the Rating fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Rating filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RatingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Rating.prisma().count()

        # results: prisma.types.RatingCountAggregateOutput
        results = await Rating.prisma().count(
            select={
                '_all': True,
                'rating': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RatingCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RatingWhereInput] = None,
        cursor: Optional[types.RatingWhereUniqueInput] = None,
    ) -> types.RatingCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RatingCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RatingWhereInput] = None,
        cursor: Optional[types.RatingWhereUniqueInput] = None,
    ) -> Union[int, types.RatingCountAggregateOutput]:
        """Count the number of Rating records present in the database

        Parameters
        ----------
        select
            Select the Rating fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Rating filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RatingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Rating.prisma().count()

        # results: prisma.types.RatingCountAggregateOutput
        results = await Rating.prisma().count(
            select={
                '_all': True,
                'review': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RatingCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RatingWhereInput] = None
    ) -> int:
        """Delete multiple Rating records.

        Parameters
        ----------
        where
            Optional Rating filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Rating records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Rating records
        total = await Rating.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RatingScalarFieldKeys'],
        *,
        where: Optional['types.RatingWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RatingAvgAggregateInput'] = None,
        sum: Optional['types.RatingSumAggregateInput'] = None,
        min: Optional['types.RatingMinAggregateInput'] = None,
        max: Optional['types.RatingMaxAggregateInput'] = None,
        having: Optional['types.RatingScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RatingCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RatingScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RatingScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RatingGroupByOutput']:
        """Group Rating records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Rating fields to group records by
        where
            Rating filter to select records
        take
            Limit the maximum number of Rating records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RatingGroupByOutput]
            A list of dictionaries representing the Rating record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Rating records by userId values
        # and count how many records are in each group
        results = await Rating.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ChatSessionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ChatSession]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ChatSession.prisma().query_raw(
            'SELECT * FROM ChatSession WHERE id = $1',
            'caeghehde',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ChatSession
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ChatSession.prisma().query_first(
            'SELECT * FROM ChatSession WHERE sessionId = $1',
            'caghgfbggd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ChatSessionCreateInput,
        include: Optional[types.ChatSessionInclude] = None
    ) -> _PrismaModelT:
        """Create a new ChatSession record.

        Parameters
        ----------
        data
            ChatSession record data
        include
            Specifies which relations should be loaded on the returned ChatSession model

        Returns
        -------
        prisma.models.ChatSession
            The created ChatSession record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ChatSession record from just the required fields
        chatsession = await ChatSession.prisma().create(
            data={
                # data to create a ChatSession record
                'sessionId': 'bbidjbbjaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ChatSessionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ChatSession records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ChatSession record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ChatSession.prisma().create_many(
            data=[
                {
                    # data to create a ChatSession record
                    'sessionId': 'bfijhaejdd',
                },
                {
                    # data to create a ChatSession record
                    'sessionId': 'bcedehfiji',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ChatSessionWhereUniqueInput,
        include: Optional[types.ChatSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ChatSession record.

        Parameters
        ----------
        where
            ChatSession filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ChatSession model

        Returns
        -------
        prisma.models.ChatSession
            The deleted ChatSession record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatsession = await ChatSession.prisma().delete(
            where={
                'id': 'bdgjicijhb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ChatSessionWhereUniqueInput,
        include: Optional[types.ChatSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ChatSession record.

        Parameters
        ----------
        where
            ChatSession filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatSession model

        Returns
        -------
        prisma.models.ChatSession
            The found ChatSession record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatsession = await ChatSession.prisma().find_unique(
            where={
                'id': 'bghifjdeia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ChatSessionWhereUniqueInput,
        include: Optional[types.ChatSessionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ChatSession record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ChatSession filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatSession model

        Returns
        -------
        prisma.models.ChatSession
            The found ChatSession record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatsession = await ChatSession.prisma().find_unique_or_raise(
            where={
                'id': 'eadfcbbcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatSessionWhereInput] = None,
        cursor: Optional[types.ChatSessionWhereUniqueInput] = None,
        include: Optional[types.ChatSessionInclude] = None,
        order: Optional[Union[types.ChatSessionOrderByInput, List[types.ChatSessionOrderByInput]]] = None,
        distinct: Optional[List[types.ChatSessionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ChatSession records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ChatSession records returned
        skip
            Ignore the first N results
        where
            ChatSession filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatSession model
        order
            Order the returned ChatSession records by any field
        distinct
            Filter ChatSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ChatSession]
            The list of all ChatSession records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ChatSession records
        chatsessions = await ChatSession.prisma().find_many(take=10)

        # find the first 5 ChatSession records ordered by the userId field
        chatsessions = await ChatSession.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatSessionWhereInput] = None,
        cursor: Optional[types.ChatSessionWhereUniqueInput] = None,
        include: Optional[types.ChatSessionInclude] = None,
        order: Optional[Union[types.ChatSessionOrderByInput, List[types.ChatSessionOrderByInput]]] = None,
        distinct: Optional[List[types.ChatSessionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ChatSession record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatSession filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatSession model
        order
            Order the returned ChatSession records by any field
        distinct
            Filter ChatSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatSession
            The first ChatSession record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatSession record ordered by the createdAt field
        chatsession = await ChatSession.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatSessionWhereInput] = None,
        cursor: Optional[types.ChatSessionWhereUniqueInput] = None,
        include: Optional[types.ChatSessionInclude] = None,
        order: Optional[Union[types.ChatSessionOrderByInput, List[types.ChatSessionOrderByInput]]] = None,
        distinct: Optional[List[types.ChatSessionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ChatSession record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatSession filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatSession model
        order
            Order the returned ChatSession records by any field
        distinct
            Filter ChatSession records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatSession
            The first ChatSession record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatSession record ordered by the lastActivity field
        chatsession = await ChatSession.prisma().find_first_or_raise(
            skip=1,
            order={
                'lastActivity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ChatSessionUpdateInput,
        where: types.ChatSessionWhereUniqueInput,
        include: Optional[types.ChatSessionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ChatSession record.

        Parameters
        ----------
        data
            ChatSession record data specifying what to update
        where
            ChatSession filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ChatSession model

        Returns
        -------
        prisma.models.ChatSession
            The updated ChatSession record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        chatsession = await ChatSession.prisma().update(
            where={
                'id': 'geihgahba',
            },
            data={
                # data to update the ChatSession record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ChatSessionWhereUniqueInput,
        data: types.ChatSessionUpsertInput,
        include: Optional[types.ChatSessionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ChatSession filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ChatSession model

        Returns
        -------
        prisma.models.ChatSession
            The created or updated ChatSession record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatsession = await ChatSession.prisma().upsert(
            where={
                'id': 'gahdcdhbj',
            },
            data={
                'create': {
                    'id': 'gahdcdhbj',
                    'sessionId': 'bcedehfiji',
                },
                'update': {
                    'sessionId': 'bcedehfiji',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ChatSessionUpdateManyMutationInput,
        where: types.ChatSessionWhereInput,
    ) -> int:
        """Update multiple ChatSession records

        Parameters
        ----------
        data
            ChatSession data to update the selected ChatSession records to
        where
            Filter to select the ChatSession records to update

        Returns
        -------
        int
            The total number of ChatSession records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ChatSession records
        total = await ChatSession.prisma().update_many(
            data={
                'isActive': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatSessionWhereInput] = None,
        cursor: Optional[types.ChatSessionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ChatSession records present in the database

        Parameters
        ----------
        select
            Select the ChatSession fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatSession filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatSessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatSession.prisma().count()

        # results: prisma.types.ChatSessionCountAggregateOutput
        results = await ChatSession.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ChatSessionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatSessionWhereInput] = None,
        cursor: Optional[types.ChatSessionWhereUniqueInput] = None,
    ) -> types.ChatSessionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ChatSessionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatSessionWhereInput] = None,
        cursor: Optional[types.ChatSessionWhereUniqueInput] = None,
    ) -> Union[int, types.ChatSessionCountAggregateOutput]:
        """Count the number of ChatSession records present in the database

        Parameters
        ----------
        select
            Select the ChatSession fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatSession filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatSessionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatSession.prisma().count()

        # results: prisma.types.ChatSessionCountAggregateOutput
        results = await ChatSession.prisma().count(
            select={
                '_all': True,
                'sessionId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ChatSessionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ChatSessionWhereInput] = None
    ) -> int:
        """Delete multiple ChatSession records.

        Parameters
        ----------
        where
            Optional ChatSession filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ChatSession records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ChatSession records
        total = await ChatSession.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ChatSessionScalarFieldKeys'],
        *,
        where: Optional['types.ChatSessionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ChatSessionAvgAggregateInput'] = None,
        sum: Optional['types.ChatSessionSumAggregateInput'] = None,
        min: Optional['types.ChatSessionMinAggregateInput'] = None,
        max: Optional['types.ChatSessionMaxAggregateInput'] = None,
        having: Optional['types.ChatSessionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ChatSessionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ChatSessionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ChatSessionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ChatSessionGroupByOutput']:
        """Group ChatSession records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ChatSession fields to group records by
        where
            ChatSession filter to select records
        take
            Limit the maximum number of ChatSession records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ChatSessionGroupByOutput]
            A list of dictionaries representing the ChatSession record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ChatSession records by userId values
        # and count how many records are in each group
        results = await ChatSession.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ChatMessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ChatMessage]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ChatMessage.prisma().query_raw(
            'SELECT * FROM ChatMessage WHERE id = $1',
            629039005,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ChatMessage
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ChatMessage.prisma().query_first(
            'SELECT * FROM ChatMessage WHERE sessionId = $1',
            'bcbebgiaic',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ChatMessageCreateInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new ChatMessage record.

        Parameters
        ----------
        data
            ChatMessage record data
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The created ChatMessage record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ChatMessage record from just the required fields
        chatmessage = await ChatMessage.prisma().create(
            data={
                # data to create a ChatMessage record
                'sessionId': 'ijigbdcbj',
                'messageId': 'gfidhicai',
                'role': 'jfegcaafh',
                'content': 'bcbeiajjfa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ChatMessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ChatMessage records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ChatMessage record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ChatMessage.prisma().create_many(
            data=[
                {
                    # data to create a ChatMessage record
                    'sessionId': 'baehicaajf',
                    'messageId': 'bdachdeiga',
                    'role': 'ijdafccef',
                    'content': 'ciaaiddag',
                },
                {
                    # data to create a ChatMessage record
                    'sessionId': 'fejggijff',
                    'messageId': 'hghjaaai',
                    'role': 'cajicjjdef',
                    'content': 'cefjaadec',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ChatMessage record.

        Parameters
        ----------
        where
            ChatMessage filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The deleted ChatMessage record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().delete(
            where={
                'id': 811863863,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ChatMessage record.

        Parameters
        ----------
        where
            ChatMessage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The found ChatMessage record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().find_unique(
            where={
                'id': 1388801188,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ChatMessage record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ChatMessage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The found ChatMessage record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().find_unique_or_raise(
            where={
                'id': 752577037,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ChatMessage records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ChatMessage records returned
        skip
            Ignore the first N results
        where
            ChatMessage filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ChatMessage]
            The list of all ChatMessage records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ChatMessage records
        chatmessages = await ChatMessage.prisma().find_many(take=10)

        # find the first 5 ChatMessage records ordered by the messageId field
        chatmessages = await ChatMessage.prisma().find_many(
            take=5,
            order={
                'messageId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ChatMessage record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatMessage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatMessage
            The first ChatMessage record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatMessage record ordered by the role field
        chatmessage = await ChatMessage.prisma().find_first(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
        include: Optional[types.ChatMessageInclude] = None,
        order: Optional[Union[types.ChatMessageOrderByInput, List[types.ChatMessageOrderByInput]]] = None,
        distinct: Optional[List[types.ChatMessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ChatMessage record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ChatMessage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ChatMessage model
        order
            Order the returned ChatMessage records by any field
        distinct
            Filter ChatMessage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ChatMessage
            The first ChatMessage record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ChatMessage record ordered by the content field
        chatmessage = await ChatMessage.prisma().find_first_or_raise(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ChatMessageUpdateInput,
        where: types.ChatMessageWhereUniqueInput,
        include: Optional[types.ChatMessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ChatMessage record.

        Parameters
        ----------
        data
            ChatMessage record data specifying what to update
        where
            ChatMessage filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The updated ChatMessage record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().update(
            where={
                'id': 1187663298,
            },
            data={
                # data to update the ChatMessage record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ChatMessageWhereUniqueInput,
        data: types.ChatMessageUpsertInput,
        include: Optional[types.ChatMessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ChatMessage filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ChatMessage model

        Returns
        -------
        prisma.models.ChatMessage
            The created or updated ChatMessage record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        chatmessage = await ChatMessage.prisma().upsert(
            where={
                'id': 769681363,
            },
            data={
                'create': {
                    'id': 769681363,
                    'sessionId': 'fejggijff',
                    'messageId': 'hghjaaai',
                    'role': 'cajicjjdef',
                    'content': 'cefjaadec',
                },
                'update': {
                    'sessionId': 'fejggijff',
                    'messageId': 'hghjaaai',
                    'role': 'cajicjjdef',
                    'content': 'cefjaadec',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ChatMessageUpdateManyMutationInput,
        where: types.ChatMessageWhereInput,
    ) -> int:
        """Update multiple ChatMessage records

        Parameters
        ----------
        data
            ChatMessage data to update the selected ChatMessage records to
        where
            Filter to select the ChatMessage records to update

        Returns
        -------
        int
            The total number of ChatMessage records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ChatMessage records
        total = await ChatMessage.prisma().update_many(
            data={
                'timestamp': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ChatMessage records present in the database

        Parameters
        ----------
        select
            Select the ChatMessage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatMessage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatMessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatMessage.prisma().count()

        # results: prisma.types.ChatMessageCountAggregateOutput
        results = await ChatMessage.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ChatMessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> types.ChatMessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ChatMessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ChatMessageWhereInput] = None,
        cursor: Optional[types.ChatMessageWhereUniqueInput] = None,
    ) -> Union[int, types.ChatMessageCountAggregateOutput]:
        """Count the number of ChatMessage records present in the database

        Parameters
        ----------
        select
            Select the ChatMessage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ChatMessage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ChatMessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ChatMessage.prisma().count()

        # results: prisma.types.ChatMessageCountAggregateOutput
        results = await ChatMessage.prisma().count(
            select={
                '_all': True,
                'sessionId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ChatMessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ChatMessageWhereInput] = None
    ) -> int:
        """Delete multiple ChatMessage records.

        Parameters
        ----------
        where
            Optional ChatMessage filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ChatMessage records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ChatMessage records
        total = await ChatMessage.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ChatMessageScalarFieldKeys'],
        *,
        where: Optional['types.ChatMessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ChatMessageAvgAggregateInput'] = None,
        sum: Optional['types.ChatMessageSumAggregateInput'] = None,
        min: Optional['types.ChatMessageMinAggregateInput'] = None,
        max: Optional['types.ChatMessageMaxAggregateInput'] = None,
        having: Optional['types.ChatMessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ChatMessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ChatMessageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ChatMessageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ChatMessageGroupByOutput']:
        """Group ChatMessage records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ChatMessage fields to group records by
        where
            ChatMessage filter to select records
        take
            Limit the maximum number of ChatMessage records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ChatMessageGroupByOutput]
            A list of dictionaries representing the ChatMessage record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ChatMessage records by messageId values
        # and count how many records are in each group
        results = await ChatMessage.prisma().group_by(
            ['messageId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserPreferencesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserPreferences]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserPreferences.prisma().query_raw(
            'SELECT * FROM UserPreferences WHERE id = $1',
            1214295824,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserPreferences
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserPreferences.prisma().query_first(
            'SELECT * FROM UserPreferences WHERE userId = $1',
            1021417993,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserPreferencesCreateInput,
        include: Optional[types.UserPreferencesInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserPreferences record.

        Parameters
        ----------
        data
            UserPreferences record data
        include
            Specifies which relations should be loaded on the returned UserPreferences model

        Returns
        -------
        prisma.models.UserPreferences
            The created UserPreferences record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserPreferences record from just the required fields
        userpreferences = await UserPreferences.prisma().create(
            data={
                # data to create a UserPreferences record
                'userId': 351503374,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserPreferencesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserPreferences records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserPreferences record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserPreferences.prisma().create_many(
            data=[
                {
                    # data to create a UserPreferences record
                    'userId': 1321184815,
                },
                {
                    # data to create a UserPreferences record
                    'userId': 369732668,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserPreferencesWhereUniqueInput,
        include: Optional[types.UserPreferencesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserPreferences record.

        Parameters
        ----------
        where
            UserPreferences filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserPreferences model

        Returns
        -------
        prisma.models.UserPreferences
            The deleted UserPreferences record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpreferences = await UserPreferences.prisma().delete(
            where={
                'id': 1191235013,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserPreferencesWhereUniqueInput,
        include: Optional[types.UserPreferencesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserPreferences record.

        Parameters
        ----------
        where
            UserPreferences filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserPreferences model

        Returns
        -------
        prisma.models.UserPreferences
            The found UserPreferences record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpreferences = await UserPreferences.prisma().find_unique(
            where={
                'id': 627561242,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserPreferencesWhereUniqueInput,
        include: Optional[types.UserPreferencesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserPreferences record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserPreferences filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserPreferences model

        Returns
        -------
        prisma.models.UserPreferences
            The found UserPreferences record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpreferences = await UserPreferences.prisma().find_unique_or_raise(
            where={
                'id': 1872952907,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferencesWhereInput] = None,
        cursor: Optional[types.UserPreferencesWhereUniqueInput] = None,
        include: Optional[types.UserPreferencesInclude] = None,
        order: Optional[Union[types.UserPreferencesOrderByInput, List[types.UserPreferencesOrderByInput]]] = None,
        distinct: Optional[List[types.UserPreferencesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserPreferences records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserPreferences records returned
        skip
            Ignore the first N results
        where
            UserPreferences filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPreferences model
        order
            Order the returned UserPreferences records by any field
        distinct
            Filter UserPreferences records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserPreferences]
            The list of all UserPreferences records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserPreferences records
        userpreferences = await UserPreferences.prisma().find_many(take=10)

        # find the first 5 UserPreferences records ordered by the budgetRange field
        userpreferences = await UserPreferences.prisma().find_many(
            take=5,
            order={
                'budgetRange': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferencesWhereInput] = None,
        cursor: Optional[types.UserPreferencesWhereUniqueInput] = None,
        include: Optional[types.UserPreferencesInclude] = None,
        order: Optional[Union[types.UserPreferencesOrderByInput, List[types.UserPreferencesOrderByInput]]] = None,
        distinct: Optional[List[types.UserPreferencesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserPreferences record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserPreferences filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPreferences model
        order
            Order the returned UserPreferences records by any field
        distinct
            Filter UserPreferences records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserPreferences
            The first UserPreferences record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserPreferences record ordered by the preferredTripTypes field
        userpreferences = await UserPreferences.prisma().find_first(
            skip=1,
            order={
                'preferredTripTypes': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferencesWhereInput] = None,
        cursor: Optional[types.UserPreferencesWhereUniqueInput] = None,
        include: Optional[types.UserPreferencesInclude] = None,
        order: Optional[Union[types.UserPreferencesOrderByInput, List[types.UserPreferencesOrderByInput]]] = None,
        distinct: Optional[List[types.UserPreferencesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserPreferences record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserPreferences filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserPreferences model
        order
            Order the returned UserPreferences records by any field
        distinct
            Filter UserPreferences records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserPreferences
            The first UserPreferences record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserPreferences record ordered by the preferredCategories field
        userpreferences = await UserPreferences.prisma().find_first_or_raise(
            skip=1,
            order={
                'preferredCategories': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserPreferencesUpdateInput,
        where: types.UserPreferencesWhereUniqueInput,
        include: Optional[types.UserPreferencesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserPreferences record.

        Parameters
        ----------
        data
            UserPreferences record data specifying what to update
        where
            UserPreferences filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserPreferences model

        Returns
        -------
        prisma.models.UserPreferences
            The updated UserPreferences record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userpreferences = await UserPreferences.prisma().update(
            where={
                'id': 1793282088,
            },
            data={
                # data to update the UserPreferences record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserPreferencesWhereUniqueInput,
        data: types.UserPreferencesUpsertInput,
        include: Optional[types.UserPreferencesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserPreferences filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserPreferences model

        Returns
        -------
        prisma.models.UserPreferences
            The created or updated UserPreferences record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userpreferences = await UserPreferences.prisma().upsert(
            where={
                'id': 1814397249,
            },
            data={
                'create': {
                    'id': 1814397249,
                    'userId': 369732668,
                },
                'update': {
                    'userId': 369732668,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserPreferencesUpdateManyMutationInput,
        where: types.UserPreferencesWhereInput,
    ) -> int:
        """Update multiple UserPreferences records

        Parameters
        ----------
        data
            UserPreferences data to update the selected UserPreferences records to
        where
            Filter to select the UserPreferences records to update

        Returns
        -------
        int
            The total number of UserPreferences records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserPreferences records
        total = await UserPreferences.prisma().update_many(
            data={
                'preferredDestinations': ['bjcdajabfa']
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferencesWhereInput] = None,
        cursor: Optional[types.UserPreferencesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserPreferences records present in the database

        Parameters
        ----------
        select
            Select the UserPreferences fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserPreferences filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserPreferencesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserPreferences.prisma().count()

        # results: prisma.types.UserPreferencesCountAggregateOutput
        results = await UserPreferences.prisma().count(
            select={
                '_all': True,
                'travelStyle': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserPreferencesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferencesWhereInput] = None,
        cursor: Optional[types.UserPreferencesWhereUniqueInput] = None,
    ) -> types.UserPreferencesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserPreferencesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserPreferencesWhereInput] = None,
        cursor: Optional[types.UserPreferencesWhereUniqueInput] = None,
    ) -> Union[int, types.UserPreferencesCountAggregateOutput]:
        """Count the number of UserPreferences records present in the database

        Parameters
        ----------
        select
            Select the UserPreferences fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserPreferences filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserPreferencesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserPreferences.prisma().count()

        # results: prisma.types.UserPreferencesCountAggregateOutput
        results = await UserPreferences.prisma().count(
            select={
                '_all': True,
                'groupSize': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserPreferencesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserPreferencesWhereInput] = None
    ) -> int:
        """Delete multiple UserPreferences records.

        Parameters
        ----------
        where
            Optional UserPreferences filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserPreferences records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserPreferences records
        total = await UserPreferences.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserPreferencesScalarFieldKeys'],
        *,
        where: Optional['types.UserPreferencesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserPreferencesAvgAggregateInput'] = None,
        sum: Optional['types.UserPreferencesSumAggregateInput'] = None,
        min: Optional['types.UserPreferencesMinAggregateInput'] = None,
        max: Optional['types.UserPreferencesMaxAggregateInput'] = None,
        having: Optional['types.UserPreferencesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserPreferencesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserPreferencesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserPreferencesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserPreferencesGroupByOutput']:
        """Group UserPreferences records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserPreferences fields to group records by
        where
            UserPreferences filter to select records
        take
            Limit the maximum number of UserPreferences records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserPreferencesGroupByOutput]
            A list of dictionaries representing the UserPreferences record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserPreferences records by preferredDuration values
        # and count how many records are in each group
        results = await UserPreferences.prisma().group_by(
            ['preferredDuration'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AIContentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AIContent]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AIContent.prisma().query_raw(
            'SELECT * FROM AIContent WHERE id = $1',
            1277244455,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AIContent
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AIContent.prisma().query_first(
            'SELECT * FROM AIContent WHERE tourId = $1',
            1160857300,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AIContentCreateInput,
        include: Optional[types.AIContentInclude] = None
    ) -> _PrismaModelT:
        """Create a new AIContent record.

        Parameters
        ----------
        data
            AIContent record data
        include
            Specifies which relations should be loaded on the returned AIContent model

        Returns
        -------
        prisma.models.AIContent
            The created AIContent record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AIContent record from just the required fields
        aicontent = await AIContent.prisma().create(
            data={
                # data to create a AIContent record
                'tourId': 361230461,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AIContentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AIContent records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AIContent record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AIContent.prisma().create_many(
            data=[
                {
                    # data to create a AIContent record
                    'tourId': 1406511986,
                },
                {
                    # data to create a AIContent record
                    'tourId': 1482877891,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AIContentWhereUniqueInput,
        include: Optional[types.AIContentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AIContent record.

        Parameters
        ----------
        where
            AIContent filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AIContent model

        Returns
        -------
        prisma.models.AIContent
            The deleted AIContent record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        aicontent = await AIContent.prisma().delete(
            where={
                'id': 566623296,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AIContentWhereUniqueInput,
        include: Optional[types.AIContentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AIContent record.

        Parameters
        ----------
        where
            AIContent filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AIContent model

        Returns
        -------
        prisma.models.AIContent
            The found AIContent record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        aicontent = await AIContent.prisma().find_unique(
            where={
                'id': 229119865,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AIContentWhereUniqueInput,
        include: Optional[types.AIContentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AIContent record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AIContent filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AIContent model

        Returns
        -------
        prisma.models.AIContent
            The found AIContent record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        aicontent = await AIContent.prisma().find_unique_or_raise(
            where={
                'id': 1750011070,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AIContentWhereInput] = None,
        cursor: Optional[types.AIContentWhereUniqueInput] = None,
        include: Optional[types.AIContentInclude] = None,
        order: Optional[Union[types.AIContentOrderByInput, List[types.AIContentOrderByInput]]] = None,
        distinct: Optional[List[types.AIContentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AIContent records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AIContent records returned
        skip
            Ignore the first N results
        where
            AIContent filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AIContent model
        order
            Order the returned AIContent records by any field
        distinct
            Filter AIContent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AIContent]
            The list of all AIContent records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AIContent records
        aicontents = await AIContent.prisma().find_many(take=10)

        # find the first 5 AIContent records ordered by the personalizedDesc field
        aicontents = await AIContent.prisma().find_many(
            take=5,
            order={
                'personalizedDesc': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AIContentWhereInput] = None,
        cursor: Optional[types.AIContentWhereUniqueInput] = None,
        include: Optional[types.AIContentInclude] = None,
        order: Optional[Union[types.AIContentOrderByInput, List[types.AIContentOrderByInput]]] = None,
        distinct: Optional[List[types.AIContentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AIContent record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AIContent filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AIContent model
        order
            Order the returned AIContent records by any field
        distinct
            Filter AIContent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AIContent
            The first AIContent record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AIContent record ordered by the highlights field
        aicontent = await AIContent.prisma().find_first(
            skip=1,
            order={
                'highlights': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AIContentWhereInput] = None,
        cursor: Optional[types.AIContentWhereUniqueInput] = None,
        include: Optional[types.AIContentInclude] = None,
        order: Optional[Union[types.AIContentOrderByInput, List[types.AIContentOrderByInput]]] = None,
        distinct: Optional[List[types.AIContentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AIContent record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AIContent filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AIContent model
        order
            Order the returned AIContent records by any field
        distinct
            Filter AIContent records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AIContent
            The first AIContent record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AIContent record ordered by the recommendations field
        aicontent = await AIContent.prisma().find_first_or_raise(
            skip=1,
            order={
                'recommendations': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AIContentUpdateInput,
        where: types.AIContentWhereUniqueInput,
        include: Optional[types.AIContentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AIContent record.

        Parameters
        ----------
        data
            AIContent record data specifying what to update
        where
            AIContent filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AIContent model

        Returns
        -------
        prisma.models.AIContent
            The updated AIContent record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        aicontent = await AIContent.prisma().update(
            where={
                'id': 410943775,
            },
            data={
                # data to update the AIContent record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AIContentWhereUniqueInput,
        data: types.AIContentUpsertInput,
        include: Optional[types.AIContentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AIContent filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AIContent model

        Returns
        -------
        prisma.models.AIContent
            The created or updated AIContent record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        aicontent = await AIContent.prisma().upsert(
            where={
                'id': 909024364,
            },
            data={
                'create': {
                    'id': 909024364,
                    'tourId': 1482877891,
                },
                'update': {
                    'tourId': 1482877891,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AIContentUpdateManyMutationInput,
        where: types.AIContentWhereInput,
    ) -> int:
        """Update multiple AIContent records

        Parameters
        ----------
        data
            AIContent data to update the selected AIContent records to
        where
            Filter to select the AIContent records to update

        Returns
        -------
        int
            The total number of AIContent records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AIContent records
        total = await AIContent.prisma().update_many(
            data={
                'targetAudience': ['hffgbabgf']
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AIContentWhereInput] = None,
        cursor: Optional[types.AIContentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AIContent records present in the database

        Parameters
        ----------
        select
            Select the AIContent fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AIContent filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AIContentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AIContent.prisma().count()

        # results: prisma.types.AIContentCountAggregateOutput
        results = await AIContent.prisma().count(
            select={
                '_all': True,
                'suggestedTags': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AIContentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AIContentWhereInput] = None,
        cursor: Optional[types.AIContentWhereUniqueInput] = None,
    ) -> types.AIContentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AIContentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AIContentWhereInput] = None,
        cursor: Optional[types.AIContentWhereUniqueInput] = None,
    ) -> Union[int, types.AIContentCountAggregateOutput]:
        """Count the number of AIContent records present in the database

        Parameters
        ----------
        select
            Select the AIContent fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AIContent filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AIContentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AIContent.prisma().count()

        # results: prisma.types.AIContentCountAggregateOutput
        results = await AIContent.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AIContentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AIContentWhereInput] = None
    ) -> int:
        """Delete multiple AIContent records.

        Parameters
        ----------
        where
            Optional AIContent filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AIContent records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AIContent records
        total = await AIContent.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AIContentScalarFieldKeys'],
        *,
        where: Optional['types.AIContentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AIContentAvgAggregateInput'] = None,
        sum: Optional['types.AIContentSumAggregateInput'] = None,
        min: Optional['types.AIContentMinAggregateInput'] = None,
        max: Optional['types.AIContentMaxAggregateInput'] = None,
        having: Optional['types.AIContentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AIContentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AIContentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AIContentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AIContentGroupByOutput']:
        """Group AIContent records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AIContent fields to group records by
        where
            AIContent filter to select records
        take
            Limit the maximum number of AIContent records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AIContentGroupByOutput]
            A list of dictionaries representing the AIContent record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AIContent records by updatedAt values
        # and count how many records are in each group
        results = await AIContent.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailCampaignActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailCampaign]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailCampaign.prisma().query_raw(
            'SELECT * FROM EmailCampaign WHERE id = $1',
            1802188490,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailCampaign
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailCampaign.prisma().query_first(
            'SELECT * FROM EmailCampaign WHERE name = $1',
            'cjejbgbff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailCampaignCreateInput,
        include: Optional[types.EmailCampaignInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailCampaign record.

        Parameters
        ----------
        data
            EmailCampaign record data
        include
            Specifies which relations should be loaded on the returned EmailCampaign model

        Returns
        -------
        prisma.models.EmailCampaign
            The created EmailCampaign record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailCampaign record from just the required fields
        emailcampaign = await EmailCampaign.prisma().create(
            data={
                # data to create a EmailCampaign record
                'name': 'fgeahddae',
                'subject': 'diageigcf',
                'content': 'badagbgeha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailCampaignCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailCampaign records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailCampaign record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailCampaign.prisma().create_many(
            data=[
                {
                    # data to create a EmailCampaign record
                    'name': 'ibgebbjch',
                    'subject': 'baieajjiee',
                    'content': 'bahjhaccfd',
                },
                {
                    # data to create a EmailCampaign record
                    'name': 'hffhfabhi',
                    'subject': 'bbcigiadhb',
                    'content': 'cfjagbbae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailCampaignWhereUniqueInput,
        include: Optional[types.EmailCampaignInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailCampaign record.

        Parameters
        ----------
        where
            EmailCampaign filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailCampaign model

        Returns
        -------
        prisma.models.EmailCampaign
            The deleted EmailCampaign record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcampaign = await EmailCampaign.prisma().delete(
            where={
                'id': 1115738345,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailCampaignWhereUniqueInput,
        include: Optional[types.EmailCampaignInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailCampaign record.

        Parameters
        ----------
        where
            EmailCampaign filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailCampaign model

        Returns
        -------
        prisma.models.EmailCampaign
            The found EmailCampaign record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcampaign = await EmailCampaign.prisma().find_unique(
            where={
                'id': 1303781742,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailCampaignWhereUniqueInput,
        include: Optional[types.EmailCampaignInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailCampaign record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailCampaign filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailCampaign model

        Returns
        -------
        prisma.models.EmailCampaign
            The found EmailCampaign record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcampaign = await EmailCampaign.prisma().find_unique_or_raise(
            where={
                'id': 1573908495,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignWhereInput] = None,
        cursor: Optional[types.EmailCampaignWhereUniqueInput] = None,
        include: Optional[types.EmailCampaignInclude] = None,
        order: Optional[Union[types.EmailCampaignOrderByInput, List[types.EmailCampaignOrderByInput]]] = None,
        distinct: Optional[List[types.EmailCampaignScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailCampaign records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailCampaign records returned
        skip
            Ignore the first N results
        where
            EmailCampaign filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailCampaign model
        order
            Order the returned EmailCampaign records by any field
        distinct
            Filter EmailCampaign records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailCampaign]
            The list of all EmailCampaign records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailCampaign records
        emailcampaigns = await EmailCampaign.prisma().find_many(take=10)

        # find the first 5 EmailCampaign records ordered by the subject field
        emailcampaigns = await EmailCampaign.prisma().find_many(
            take=5,
            order={
                'subject': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignWhereInput] = None,
        cursor: Optional[types.EmailCampaignWhereUniqueInput] = None,
        include: Optional[types.EmailCampaignInclude] = None,
        order: Optional[Union[types.EmailCampaignOrderByInput, List[types.EmailCampaignOrderByInput]]] = None,
        distinct: Optional[List[types.EmailCampaignScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailCampaign record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailCampaign filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailCampaign model
        order
            Order the returned EmailCampaign records by any field
        distinct
            Filter EmailCampaign records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailCampaign
            The first EmailCampaign record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailCampaign record ordered by the content field
        emailcampaign = await EmailCampaign.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignWhereInput] = None,
        cursor: Optional[types.EmailCampaignWhereUniqueInput] = None,
        include: Optional[types.EmailCampaignInclude] = None,
        order: Optional[Union[types.EmailCampaignOrderByInput, List[types.EmailCampaignOrderByInput]]] = None,
        distinct: Optional[List[types.EmailCampaignScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailCampaign record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailCampaign filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailCampaign model
        order
            Order the returned EmailCampaign records by any field
        distinct
            Filter EmailCampaign records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailCampaign
            The first EmailCampaign record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailCampaign record ordered by the htmlContent field
        emailcampaign = await EmailCampaign.prisma().find_first_or_raise(
            skip=1,
            order={
                'htmlContent': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailCampaignUpdateInput,
        where: types.EmailCampaignWhereUniqueInput,
        include: Optional[types.EmailCampaignInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailCampaign record.

        Parameters
        ----------
        data
            EmailCampaign record data specifying what to update
        where
            EmailCampaign filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailCampaign model

        Returns
        -------
        prisma.models.EmailCampaign
            The updated EmailCampaign record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailcampaign = await EmailCampaign.prisma().update(
            where={
                'id': 1195899036,
            },
            data={
                # data to update the EmailCampaign record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailCampaignWhereUniqueInput,
        data: types.EmailCampaignUpsertInput,
        include: Optional[types.EmailCampaignInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailCampaign filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailCampaign model

        Returns
        -------
        prisma.models.EmailCampaign
            The created or updated EmailCampaign record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcampaign = await EmailCampaign.prisma().upsert(
            where={
                'id': 739021477,
            },
            data={
                'create': {
                    'id': 739021477,
                    'name': 'hffhfabhi',
                    'subject': 'bbcigiadhb',
                    'content': 'cfjagbbae',
                },
                'update': {
                    'name': 'hffhfabhi',
                    'subject': 'bbcigiadhb',
                    'content': 'cfjagbbae',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailCampaignUpdateManyMutationInput,
        where: types.EmailCampaignWhereInput,
    ) -> int:
        """Update multiple EmailCampaign records

        Parameters
        ----------
        data
            EmailCampaign data to update the selected EmailCampaign records to
        where
            Filter to select the EmailCampaign records to update

        Returns
        -------
        int
            The total number of EmailCampaign records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailCampaign records
        total = await EmailCampaign.prisma().update_many(
            data={
                'status': enums.EmailCampaignStatus.DRAFT
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignWhereInput] = None,
        cursor: Optional[types.EmailCampaignWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailCampaign records present in the database

        Parameters
        ----------
        select
            Select the EmailCampaign fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailCampaign filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailCampaignCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailCampaign.prisma().count()

        # results: prisma.types.EmailCampaignCountAggregateOutput
        results = await EmailCampaign.prisma().count(
            select={
                '_all': True,
                'targetAudience': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailCampaignCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignWhereInput] = None,
        cursor: Optional[types.EmailCampaignWhereUniqueInput] = None,
    ) -> types.EmailCampaignCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailCampaignCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignWhereInput] = None,
        cursor: Optional[types.EmailCampaignWhereUniqueInput] = None,
    ) -> Union[int, types.EmailCampaignCountAggregateOutput]:
        """Count the number of EmailCampaign records present in the database

        Parameters
        ----------
        select
            Select the EmailCampaign fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailCampaign filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailCampaignCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailCampaign.prisma().count()

        # results: prisma.types.EmailCampaignCountAggregateOutput
        results = await EmailCampaign.prisma().count(
            select={
                '_all': True,
                'scheduledAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailCampaignCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailCampaignWhereInput] = None
    ) -> int:
        """Delete multiple EmailCampaign records.

        Parameters
        ----------
        where
            Optional EmailCampaign filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailCampaign records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailCampaign records
        total = await EmailCampaign.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailCampaignScalarFieldKeys'],
        *,
        where: Optional['types.EmailCampaignWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailCampaignAvgAggregateInput'] = None,
        sum: Optional['types.EmailCampaignSumAggregateInput'] = None,
        min: Optional['types.EmailCampaignMinAggregateInput'] = None,
        max: Optional['types.EmailCampaignMaxAggregateInput'] = None,
        having: Optional['types.EmailCampaignScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailCampaignCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailCampaignScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailCampaignScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailCampaignGroupByOutput']:
        """Group EmailCampaign records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailCampaign fields to group records by
        where
            EmailCampaign filter to select records
        take
            Limit the maximum number of EmailCampaign records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailCampaignGroupByOutput]
            A list of dictionaries representing the EmailCampaign record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailCampaign records by sentAt values
        # and count how many records are in each group
        results = await EmailCampaign.prisma().group_by(
            ['sentAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailCampaignSendActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailCampaignSend]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailCampaignSend.prisma().query_raw(
            'SELECT * FROM EmailCampaignSend WHERE id = $1',
            1722214010,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailCampaignSend
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailCampaignSend.prisma().query_first(
            'SELECT * FROM EmailCampaignSend WHERE campaignId = $1',
            1269136939,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailCampaignSendCreateInput,
        include: Optional[types.EmailCampaignSendInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailCampaignSend record.

        Parameters
        ----------
        data
            EmailCampaignSend record data
        include
            Specifies which relations should be loaded on the returned EmailCampaignSend model

        Returns
        -------
        prisma.models.EmailCampaignSend
            The created EmailCampaignSend record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailCampaignSend record from just the required fields
        emailcampaignsend = await EmailCampaignSend.prisma().create(
            data={
                # data to create a EmailCampaignSend record
                'campaignId': 573178504,
                'userId': 1440265249,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailCampaignSendCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailCampaignSend records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailCampaignSend record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailCampaignSend.prisma().create_many(
            data=[
                {
                    # data to create a EmailCampaignSend record
                    'campaignId': 1185738822,
                    'userId': 1694224903,
                },
                {
                    # data to create a EmailCampaignSend record
                    'campaignId': 1906360116,
                    'userId': 1911255389,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailCampaignSendWhereUniqueInput,
        include: Optional[types.EmailCampaignSendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailCampaignSend record.

        Parameters
        ----------
        where
            EmailCampaignSend filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailCampaignSend model

        Returns
        -------
        prisma.models.EmailCampaignSend
            The deleted EmailCampaignSend record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcampaignsend = await EmailCampaignSend.prisma().delete(
            where={
                'id': 146262738,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailCampaignSendWhereUniqueInput,
        include: Optional[types.EmailCampaignSendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailCampaignSend record.

        Parameters
        ----------
        where
            EmailCampaignSend filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailCampaignSend model

        Returns
        -------
        prisma.models.EmailCampaignSend
            The found EmailCampaignSend record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcampaignsend = await EmailCampaignSend.prisma().find_unique(
            where={
                'id': 1719240611,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailCampaignSendWhereUniqueInput,
        include: Optional[types.EmailCampaignSendInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailCampaignSend record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailCampaignSend filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailCampaignSend model

        Returns
        -------
        prisma.models.EmailCampaignSend
            The found EmailCampaignSend record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcampaignsend = await EmailCampaignSend.prisma().find_unique_or_raise(
            where={
                'id': 1948555936,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignSendWhereInput] = None,
        cursor: Optional[types.EmailCampaignSendWhereUniqueInput] = None,
        include: Optional[types.EmailCampaignSendInclude] = None,
        order: Optional[Union[types.EmailCampaignSendOrderByInput, List[types.EmailCampaignSendOrderByInput]]] = None,
        distinct: Optional[List[types.EmailCampaignSendScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailCampaignSend records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailCampaignSend records returned
        skip
            Ignore the first N results
        where
            EmailCampaignSend filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailCampaignSend model
        order
            Order the returned EmailCampaignSend records by any field
        distinct
            Filter EmailCampaignSend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailCampaignSend]
            The list of all EmailCampaignSend records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailCampaignSend records
        emailcampaignsends = await EmailCampaignSend.prisma().find_many(take=10)

        # find the first 5 EmailCampaignSend records ordered by the userId field
        emailcampaignsends = await EmailCampaignSend.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignSendWhereInput] = None,
        cursor: Optional[types.EmailCampaignSendWhereUniqueInput] = None,
        include: Optional[types.EmailCampaignSendInclude] = None,
        order: Optional[Union[types.EmailCampaignSendOrderByInput, List[types.EmailCampaignSendOrderByInput]]] = None,
        distinct: Optional[List[types.EmailCampaignSendScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailCampaignSend record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailCampaignSend filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailCampaignSend model
        order
            Order the returned EmailCampaignSend records by any field
        distinct
            Filter EmailCampaignSend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailCampaignSend
            The first EmailCampaignSend record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailCampaignSend record ordered by the status field
        emailcampaignsend = await EmailCampaignSend.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignSendWhereInput] = None,
        cursor: Optional[types.EmailCampaignSendWhereUniqueInput] = None,
        include: Optional[types.EmailCampaignSendInclude] = None,
        order: Optional[Union[types.EmailCampaignSendOrderByInput, List[types.EmailCampaignSendOrderByInput]]] = None,
        distinct: Optional[List[types.EmailCampaignSendScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailCampaignSend record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailCampaignSend filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailCampaignSend model
        order
            Order the returned EmailCampaignSend records by any field
        distinct
            Filter EmailCampaignSend records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailCampaignSend
            The first EmailCampaignSend record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailCampaignSend record ordered by the sentAt field
        emailcampaignsend = await EmailCampaignSend.prisma().find_first_or_raise(
            skip=1,
            order={
                'sentAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailCampaignSendUpdateInput,
        where: types.EmailCampaignSendWhereUniqueInput,
        include: Optional[types.EmailCampaignSendInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailCampaignSend record.

        Parameters
        ----------
        data
            EmailCampaignSend record data specifying what to update
        where
            EmailCampaignSend filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailCampaignSend model

        Returns
        -------
        prisma.models.EmailCampaignSend
            The updated EmailCampaignSend record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailcampaignsend = await EmailCampaignSend.prisma().update(
            where={
                'id': 1383253593,
            },
            data={
                # data to update the EmailCampaignSend record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailCampaignSendWhereUniqueInput,
        data: types.EmailCampaignSendUpsertInput,
        include: Optional[types.EmailCampaignSendInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailCampaignSend filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailCampaignSend model

        Returns
        -------
        prisma.models.EmailCampaignSend
            The created or updated EmailCampaignSend record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailcampaignsend = await EmailCampaignSend.prisma().upsert(
            where={
                'id': 354664990,
            },
            data={
                'create': {
                    'id': 354664990,
                    'campaignId': 1906360116,
                    'userId': 1911255389,
                },
                'update': {
                    'campaignId': 1906360116,
                    'userId': 1911255389,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailCampaignSendUpdateManyMutationInput,
        where: types.EmailCampaignSendWhereInput,
    ) -> int:
        """Update multiple EmailCampaignSend records

        Parameters
        ----------
        data
            EmailCampaignSend data to update the selected EmailCampaignSend records to
        where
            Filter to select the EmailCampaignSend records to update

        Returns
        -------
        int
            The total number of EmailCampaignSend records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailCampaignSend records
        total = await EmailCampaignSend.prisma().update_many(
            data={
                'deliveredAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignSendWhereInput] = None,
        cursor: Optional[types.EmailCampaignSendWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailCampaignSend records present in the database

        Parameters
        ----------
        select
            Select the EmailCampaignSend fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailCampaignSend filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailCampaignSendCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailCampaignSend.prisma().count()

        # results: prisma.types.EmailCampaignSendCountAggregateOutput
        results = await EmailCampaignSend.prisma().count(
            select={
                '_all': True,
                'openedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailCampaignSendCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignSendWhereInput] = None,
        cursor: Optional[types.EmailCampaignSendWhereUniqueInput] = None,
    ) -> types.EmailCampaignSendCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailCampaignSendCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailCampaignSendWhereInput] = None,
        cursor: Optional[types.EmailCampaignSendWhereUniqueInput] = None,
    ) -> Union[int, types.EmailCampaignSendCountAggregateOutput]:
        """Count the number of EmailCampaignSend records present in the database

        Parameters
        ----------
        select
            Select the EmailCampaignSend fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailCampaignSend filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailCampaignSendCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailCampaignSend.prisma().count()

        # results: prisma.types.EmailCampaignSendCountAggregateOutput
        results = await EmailCampaignSend.prisma().count(
            select={
                '_all': True,
                'clickedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailCampaignSendCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailCampaignSendWhereInput] = None
    ) -> int:
        """Delete multiple EmailCampaignSend records.

        Parameters
        ----------
        where
            Optional EmailCampaignSend filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailCampaignSend records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailCampaignSend records
        total = await EmailCampaignSend.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailCampaignSendScalarFieldKeys'],
        *,
        where: Optional['types.EmailCampaignSendWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailCampaignSendAvgAggregateInput'] = None,
        sum: Optional['types.EmailCampaignSendSumAggregateInput'] = None,
        min: Optional['types.EmailCampaignSendMinAggregateInput'] = None,
        max: Optional['types.EmailCampaignSendMaxAggregateInput'] = None,
        having: Optional['types.EmailCampaignSendScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailCampaignSendCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailCampaignSendScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailCampaignSendScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailCampaignSendGroupByOutput']:
        """Group EmailCampaignSend records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailCampaignSend fields to group records by
        where
            EmailCampaignSend filter to select records
        take
            Limit the maximum number of EmailCampaignSend records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailCampaignSendGroupByOutput]
            A list of dictionaries representing the EmailCampaignSend record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailCampaignSend records by unsubscribedAt values
        # and count how many records are in each group
        results = await EmailCampaignSend.prisma().group_by(
            ['unsubscribedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class EmailTemplateActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.EmailTemplate]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await EmailTemplate.prisma().query_raw(
            'SELECT * FROM EmailTemplate WHERE id = $1',
            647166719,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.EmailTemplate
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await EmailTemplate.prisma().query_first(
            'SELECT * FROM EmailTemplate WHERE name = $1',
            'dfhaijeie',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.EmailTemplateCreateInput,
        include: Optional[types.EmailTemplateInclude] = None
    ) -> _PrismaModelT:
        """Create a new EmailTemplate record.

        Parameters
        ----------
        data
            EmailTemplate record data
        include
            Specifies which relations should be loaded on the returned EmailTemplate model

        Returns
        -------
        prisma.models.EmailTemplate
            The created EmailTemplate record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a EmailTemplate record from just the required fields
        emailtemplate = await EmailTemplate.prisma().create(
            data={
                # data to create a EmailTemplate record
                'name': 'gbcdjgicb',
                'subject': 'biaibdagac',
                'content': 'bbfbheibcd',
                'type': enums.EmailTemplateType.WELCOME,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.EmailTemplateCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple EmailTemplate records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of EmailTemplate record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await EmailTemplate.prisma().create_many(
            data=[
                {
                    # data to create a EmailTemplate record
                    'name': 'hiagajie',
                    'subject': 'eeejidbif',
                    'content': 'efgbahec',
                    'type': enums.EmailTemplateType.WELCOME,
                },
                {
                    # data to create a EmailTemplate record
                    'name': 'hgjaiebfb',
                    'subject': 'bddefjjabc',
                    'content': 'bbbghgbadh',
                    'type': enums.EmailTemplateType.WELCOME,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.EmailTemplateWhereUniqueInput,
        include: Optional[types.EmailTemplateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single EmailTemplate record.

        Parameters
        ----------
        where
            EmailTemplate filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned EmailTemplate model

        Returns
        -------
        prisma.models.EmailTemplate
            The deleted EmailTemplate record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailtemplate = await EmailTemplate.prisma().delete(
            where={
                'id': 1172606082,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.EmailTemplateWhereUniqueInput,
        include: Optional[types.EmailTemplateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique EmailTemplate record.

        Parameters
        ----------
        where
            EmailTemplate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailTemplate model

        Returns
        -------
        prisma.models.EmailTemplate
            The found EmailTemplate record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailtemplate = await EmailTemplate.prisma().find_unique(
            where={
                'id': 330014611,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.EmailTemplateWhereUniqueInput,
        include: Optional[types.EmailTemplateInclude] = None
    ) -> _PrismaModelT:
        """Find a unique EmailTemplate record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            EmailTemplate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned EmailTemplate model

        Returns
        -------
        prisma.models.EmailTemplate
            The found EmailTemplate record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailtemplate = await EmailTemplate.prisma().find_unique_or_raise(
            where={
                'id': 1768156112,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailTemplateWhereInput] = None,
        cursor: Optional[types.EmailTemplateWhereUniqueInput] = None,
        include: Optional[types.EmailTemplateInclude] = None,
        order: Optional[Union[types.EmailTemplateOrderByInput, List[types.EmailTemplateOrderByInput]]] = None,
        distinct: Optional[List[types.EmailTemplateScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple EmailTemplate records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of EmailTemplate records returned
        skip
            Ignore the first N results
        where
            EmailTemplate filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailTemplate model
        order
            Order the returned EmailTemplate records by any field
        distinct
            Filter EmailTemplate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.EmailTemplate]
            The list of all EmailTemplate records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 EmailTemplate records
        emailtemplates = await EmailTemplate.prisma().find_many(take=10)

        # find the first 5 EmailTemplate records ordered by the subject field
        emailtemplates = await EmailTemplate.prisma().find_many(
            take=5,
            order={
                'subject': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailTemplateWhereInput] = None,
        cursor: Optional[types.EmailTemplateWhereUniqueInput] = None,
        include: Optional[types.EmailTemplateInclude] = None,
        order: Optional[Union[types.EmailTemplateOrderByInput, List[types.EmailTemplateOrderByInput]]] = None,
        distinct: Optional[List[types.EmailTemplateScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single EmailTemplate record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailTemplate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailTemplate model
        order
            Order the returned EmailTemplate records by any field
        distinct
            Filter EmailTemplate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailTemplate
            The first EmailTemplate record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailTemplate record ordered by the content field
        emailtemplate = await EmailTemplate.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.EmailTemplateWhereInput] = None,
        cursor: Optional[types.EmailTemplateWhereUniqueInput] = None,
        include: Optional[types.EmailTemplateInclude] = None,
        order: Optional[Union[types.EmailTemplateOrderByInput, List[types.EmailTemplateOrderByInput]]] = None,
        distinct: Optional[List[types.EmailTemplateScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single EmailTemplate record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            EmailTemplate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned EmailTemplate model
        order
            Order the returned EmailTemplate records by any field
        distinct
            Filter EmailTemplate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.EmailTemplate
            The first EmailTemplate record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second EmailTemplate record ordered by the htmlContent field
        emailtemplate = await EmailTemplate.prisma().find_first_or_raise(
            skip=1,
            order={
                'htmlContent': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.EmailTemplateUpdateInput,
        where: types.EmailTemplateWhereUniqueInput,
        include: Optional[types.EmailTemplateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single EmailTemplate record.

        Parameters
        ----------
        data
            EmailTemplate record data specifying what to update
        where
            EmailTemplate filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned EmailTemplate model

        Returns
        -------
        prisma.models.EmailTemplate
            The updated EmailTemplate record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        emailtemplate = await EmailTemplate.prisma().update(
            where={
                'id': 71628745,
            },
            data={
                # data to update the EmailTemplate record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.EmailTemplateWhereUniqueInput,
        data: types.EmailTemplateUpsertInput,
        include: Optional[types.EmailTemplateInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            EmailTemplate filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned EmailTemplate model

        Returns
        -------
        prisma.models.EmailTemplate
            The created or updated EmailTemplate record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        emailtemplate = await EmailTemplate.prisma().upsert(
            where={
                'id': 55766734,
            },
            data={
                'create': {
                    'id': 55766734,
                    'name': 'hgjaiebfb',
                    'subject': 'bddefjjabc',
                    'content': 'bbbghgbadh',
                    'type': enums.EmailTemplateType.WELCOME,
                },
                'update': {
                    'name': 'hgjaiebfb',
                    'subject': 'bddefjjabc',
                    'content': 'bbbghgbadh',
                    'type': enums.EmailTemplateType.WELCOME,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.EmailTemplateUpdateManyMutationInput,
        where: types.EmailTemplateWhereInput,
    ) -> int:
        """Update multiple EmailTemplate records

        Parameters
        ----------
        data
            EmailTemplate data to update the selected EmailTemplate records to
        where
            Filter to select the EmailTemplate records to update

        Returns
        -------
        int
            The total number of EmailTemplate records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all EmailTemplate records
        total = await EmailTemplate.prisma().update_many(
            data={
                'type': enums.EmailTemplateType.WELCOME
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailTemplateWhereInput] = None,
        cursor: Optional[types.EmailTemplateWhereUniqueInput] = None,
    ) -> int:
        """Count the number of EmailTemplate records present in the database

        Parameters
        ----------
        select
            Select the EmailTemplate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailTemplate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailTemplateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailTemplate.prisma().count()

        # results: prisma.types.EmailTemplateCountAggregateOutput
        results = await EmailTemplate.prisma().count(
            select={
                '_all': True,
                'variables': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.EmailTemplateCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailTemplateWhereInput] = None,
        cursor: Optional[types.EmailTemplateWhereUniqueInput] = None,
    ) -> types.EmailTemplateCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.EmailTemplateCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.EmailTemplateWhereInput] = None,
        cursor: Optional[types.EmailTemplateWhereUniqueInput] = None,
    ) -> Union[int, types.EmailTemplateCountAggregateOutput]:
        """Count the number of EmailTemplate records present in the database

        Parameters
        ----------
        select
            Select the EmailTemplate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            EmailTemplate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.EmailTemplateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await EmailTemplate.prisma().count()

        # results: prisma.types.EmailTemplateCountAggregateOutput
        results = await EmailTemplate.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.EmailTemplateCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.EmailTemplateWhereInput] = None
    ) -> int:
        """Delete multiple EmailTemplate records.

        Parameters
        ----------
        where
            Optional EmailTemplate filter to find the records to be deleted

        Returns
        -------
        int
            The total number of EmailTemplate records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all EmailTemplate records
        total = await EmailTemplate.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.EmailTemplateScalarFieldKeys'],
        *,
        where: Optional['types.EmailTemplateWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.EmailTemplateAvgAggregateInput'] = None,
        sum: Optional['types.EmailTemplateSumAggregateInput'] = None,
        min: Optional['types.EmailTemplateMinAggregateInput'] = None,
        max: Optional['types.EmailTemplateMaxAggregateInput'] = None,
        having: Optional['types.EmailTemplateScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.EmailTemplateCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.EmailTemplateScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.EmailTemplateScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.EmailTemplateGroupByOutput']:
        """Group EmailTemplate records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar EmailTemplate fields to group records by
        where
            EmailTemplate filter to select records
        take
            Limit the maximum number of EmailTemplate records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.EmailTemplateGroupByOutput]
            A list of dictionaries representing the EmailTemplate record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group EmailTemplate records by createdAt values
        # and count how many records are in each group
        results = await EmailTemplate.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AutomationRulesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AutomationRules]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AutomationRules.prisma().query_raw(
            'SELECT * FROM AutomationRules WHERE id = $1',
            812032495,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AutomationRules
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AutomationRules.prisma().query_first(
            'SELECT * FROM AutomationRules WHERE name = $1',
            'bdcdfgccdg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AutomationRulesCreateInput,
        include: Optional[types.AutomationRulesInclude] = None
    ) -> _PrismaModelT:
        """Create a new AutomationRules record.

        Parameters
        ----------
        data
            AutomationRules record data
        include
            Specifies which relations should be loaded on the returned AutomationRules model

        Returns
        -------
        prisma.models.AutomationRules
            The created AutomationRules record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AutomationRules record from just the required fields
        automationrules = await AutomationRules.prisma().create(
            data={
                # data to create a AutomationRules record
                'name': 'edhjgdfh',
                'triggerType': 'bdeffdadda',
                'conditions': Json({'bjgfdihchf': True}),
                'actions': Json({'iaeihdeei': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AutomationRulesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AutomationRules records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AutomationRules record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AutomationRules.prisma().create_many(
            data=[
                {
                    # data to create a AutomationRules record
                    'name': 'bfggejgfbd',
                    'triggerType': 'ifaaaedja',
                    'conditions': Json({'cbajdjjabf': True}),
                    'actions': Json({'bcicggedea': True}),
                },
                {
                    # data to create a AutomationRules record
                    'name': 'cebcdadjh',
                    'triggerType': 'ehfigdgac',
                    'conditions': Json({'bhbgccijjf': True}),
                    'actions': Json({'bigjhdgbjc': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AutomationRulesWhereUniqueInput,
        include: Optional[types.AutomationRulesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AutomationRules record.

        Parameters
        ----------
        where
            AutomationRules filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AutomationRules model

        Returns
        -------
        prisma.models.AutomationRules
            The deleted AutomationRules record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automationrules = await AutomationRules.prisma().delete(
            where={
                'id': 1585341753,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AutomationRulesWhereUniqueInput,
        include: Optional[types.AutomationRulesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AutomationRules record.

        Parameters
        ----------
        where
            AutomationRules filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AutomationRules model

        Returns
        -------
        prisma.models.AutomationRules
            The found AutomationRules record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automationrules = await AutomationRules.prisma().find_unique(
            where={
                'id': 29271934,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AutomationRulesWhereUniqueInput,
        include: Optional[types.AutomationRulesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AutomationRules record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AutomationRules filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AutomationRules model

        Returns
        -------
        prisma.models.AutomationRules
            The found AutomationRules record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automationrules = await AutomationRules.prisma().find_unique_or_raise(
            where={
                'id': 1588192479,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomationRulesWhereInput] = None,
        cursor: Optional[types.AutomationRulesWhereUniqueInput] = None,
        include: Optional[types.AutomationRulesInclude] = None,
        order: Optional[Union[types.AutomationRulesOrderByInput, List[types.AutomationRulesOrderByInput]]] = None,
        distinct: Optional[List[types.AutomationRulesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AutomationRules records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AutomationRules records returned
        skip
            Ignore the first N results
        where
            AutomationRules filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AutomationRules model
        order
            Order the returned AutomationRules records by any field
        distinct
            Filter AutomationRules records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AutomationRules]
            The list of all AutomationRules records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AutomationRules records
        automationrules = await AutomationRules.prisma().find_many(take=10)

        # find the first 5 AutomationRules records ordered by the description field
        automationrules = await AutomationRules.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AutomationRulesWhereInput] = None,
        cursor: Optional[types.AutomationRulesWhereUniqueInput] = None,
        include: Optional[types.AutomationRulesInclude] = None,
        order: Optional[Union[types.AutomationRulesOrderByInput, List[types.AutomationRulesOrderByInput]]] = None,
        distinct: Optional[List[types.AutomationRulesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AutomationRules record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AutomationRules filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AutomationRules model
        order
            Order the returned AutomationRules records by any field
        distinct
            Filter AutomationRules records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AutomationRules
            The first AutomationRules record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AutomationRules record ordered by the triggerType field
        automationrules = await AutomationRules.prisma().find_first(
            skip=1,
            order={
                'triggerType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AutomationRulesWhereInput] = None,
        cursor: Optional[types.AutomationRulesWhereUniqueInput] = None,
        include: Optional[types.AutomationRulesInclude] = None,
        order: Optional[Union[types.AutomationRulesOrderByInput, List[types.AutomationRulesOrderByInput]]] = None,
        distinct: Optional[List[types.AutomationRulesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AutomationRules record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AutomationRules filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AutomationRules model
        order
            Order the returned AutomationRules records by any field
        distinct
            Filter AutomationRules records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AutomationRules
            The first AutomationRules record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AutomationRules record ordered by the conditions field
        automationrules = await AutomationRules.prisma().find_first_or_raise(
            skip=1,
            order={
                'conditions': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AutomationRulesUpdateInput,
        where: types.AutomationRulesWhereUniqueInput,
        include: Optional[types.AutomationRulesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AutomationRules record.

        Parameters
        ----------
        data
            AutomationRules record data specifying what to update
        where
            AutomationRules filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AutomationRules model

        Returns
        -------
        prisma.models.AutomationRules
            The updated AutomationRules record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        automationrules = await AutomationRules.prisma().update(
            where={
                'id': 898405676,
            },
            data={
                # data to update the AutomationRules record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AutomationRulesWhereUniqueInput,
        data: types.AutomationRulesUpsertInput,
        include: Optional[types.AutomationRulesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AutomationRules filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AutomationRules model

        Returns
        -------
        prisma.models.AutomationRules
            The created or updated AutomationRules record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automationrules = await AutomationRules.prisma().upsert(
            where={
                'id': 777460725,
            },
            data={
                'create': {
                    'id': 777460725,
                    'name': 'cebcdadjh',
                    'triggerType': 'ehfigdgac',
                    'conditions': Json({'bhbgccijjf': True}),
                    'actions': Json({'bigjhdgbjc': True}),
                },
                'update': {
                    'name': 'cebcdadjh',
                    'triggerType': 'ehfigdgac',
                    'conditions': Json({'bhbgccijjf': True}),
                    'actions': Json({'bigjhdgbjc': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AutomationRulesUpdateManyMutationInput,
        where: types.AutomationRulesWhereInput,
    ) -> int:
        """Update multiple AutomationRules records

        Parameters
        ----------
        data
            AutomationRules data to update the selected AutomationRules records to
        where
            Filter to select the AutomationRules records to update

        Returns
        -------
        int
            The total number of AutomationRules records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AutomationRules records
        total = await AutomationRules.prisma().update_many(
            data={
                'actions': Json({'edhijefdi': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomationRulesWhereInput] = None,
        cursor: Optional[types.AutomationRulesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AutomationRules records present in the database

        Parameters
        ----------
        select
            Select the AutomationRules fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AutomationRules filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AutomationRulesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AutomationRules.prisma().count()

        # results: prisma.types.AutomationRulesCountAggregateOutput
        results = await AutomationRules.prisma().count(
            select={
                '_all': True,
                'isActive': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AutomationRulesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomationRulesWhereInput] = None,
        cursor: Optional[types.AutomationRulesWhereUniqueInput] = None,
    ) -> types.AutomationRulesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AutomationRulesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomationRulesWhereInput] = None,
        cursor: Optional[types.AutomationRulesWhereUniqueInput] = None,
    ) -> Union[int, types.AutomationRulesCountAggregateOutput]:
        """Count the number of AutomationRules records present in the database

        Parameters
        ----------
        select
            Select the AutomationRules fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AutomationRules filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AutomationRulesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AutomationRules.prisma().count()

        # results: prisma.types.AutomationRulesCountAggregateOutput
        results = await AutomationRules.prisma().count(
            select={
                '_all': True,
                'lastExecuted': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AutomationRulesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AutomationRulesWhereInput] = None
    ) -> int:
        """Delete multiple AutomationRules records.

        Parameters
        ----------
        where
            Optional AutomationRules filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AutomationRules records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AutomationRules records
        total = await AutomationRules.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AutomationRulesScalarFieldKeys'],
        *,
        where: Optional['types.AutomationRulesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AutomationRulesAvgAggregateInput'] = None,
        sum: Optional['types.AutomationRulesSumAggregateInput'] = None,
        min: Optional['types.AutomationRulesMinAggregateInput'] = None,
        max: Optional['types.AutomationRulesMaxAggregateInput'] = None,
        having: Optional['types.AutomationRulesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AutomationRulesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AutomationRulesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AutomationRulesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AutomationRulesGroupByOutput']:
        """Group AutomationRules records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AutomationRules fields to group records by
        where
            AutomationRules filter to select records
        take
            Limit the maximum number of AutomationRules records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AutomationRulesGroupByOutput]
            A list of dictionaries representing the AutomationRules record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AutomationRules records by executionCount values
        # and count how many records are in each group
        results = await AutomationRules.prisma().group_by(
            ['executionCount'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AutomationLogsActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AutomationLogs]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AutomationLogs.prisma().query_raw(
            'SELECT * FROM AutomationLogs WHERE id = $1',
            393342971,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AutomationLogs
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AutomationLogs.prisma().query_first(
            'SELECT * FROM AutomationLogs WHERE ruleId = $1',
            163829784,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AutomationLogsCreateInput,
        include: Optional[types.AutomationLogsInclude] = None
    ) -> _PrismaModelT:
        """Create a new AutomationLogs record.

        Parameters
        ----------
        data
            AutomationLogs record data
        include
            Specifies which relations should be loaded on the returned AutomationLogs model

        Returns
        -------
        prisma.models.AutomationLogs
            The created AutomationLogs record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AutomationLogs record from just the required fields
        automationlogs = await AutomationLogs.prisma().create(
            data={
                # data to create a AutomationLogs record
                'ruleId': 248152689,
                'action': 'debhbfada',
                'status': 'bgjchggecd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AutomationLogsCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AutomationLogs records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AutomationLogs record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AutomationLogs.prisma().create_many(
            data=[
                {
                    # data to create a AutomationLogs record
                    'ruleId': 86662596,
                    'action': 'bgjhijffjh',
                    'status': 'bcigdhache',
                },
                {
                    # data to create a AutomationLogs record
                    'ruleId': 864576371,
                    'action': 'ejbiifbae',
                    'status': 'djcfgedjd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AutomationLogsWhereUniqueInput,
        include: Optional[types.AutomationLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AutomationLogs record.

        Parameters
        ----------
        where
            AutomationLogs filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AutomationLogs model

        Returns
        -------
        prisma.models.AutomationLogs
            The deleted AutomationLogs record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automationlogs = await AutomationLogs.prisma().delete(
            where={
                'id': 1319234606,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AutomationLogsWhereUniqueInput,
        include: Optional[types.AutomationLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AutomationLogs record.

        Parameters
        ----------
        where
            AutomationLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AutomationLogs model

        Returns
        -------
        prisma.models.AutomationLogs
            The found AutomationLogs record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automationlogs = await AutomationLogs.prisma().find_unique(
            where={
                'id': 712754127,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AutomationLogsWhereUniqueInput,
        include: Optional[types.AutomationLogsInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AutomationLogs record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AutomationLogs filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AutomationLogs model

        Returns
        -------
        prisma.models.AutomationLogs
            The found AutomationLogs record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automationlogs = await AutomationLogs.prisma().find_unique_or_raise(
            where={
                'id': 1299554652,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomationLogsWhereInput] = None,
        cursor: Optional[types.AutomationLogsWhereUniqueInput] = None,
        include: Optional[types.AutomationLogsInclude] = None,
        order: Optional[Union[types.AutomationLogsOrderByInput, List[types.AutomationLogsOrderByInput]]] = None,
        distinct: Optional[List[types.AutomationLogsScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AutomationLogs records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AutomationLogs records returned
        skip
            Ignore the first N results
        where
            AutomationLogs filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AutomationLogs model
        order
            Order the returned AutomationLogs records by any field
        distinct
            Filter AutomationLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AutomationLogs]
            The list of all AutomationLogs records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AutomationLogs records
        automationlogs = await AutomationLogs.prisma().find_many(take=10)

        # find the first 5 AutomationLogs records ordered by the action field
        automationlogs = await AutomationLogs.prisma().find_many(
            take=5,
            order={
                'action': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AutomationLogsWhereInput] = None,
        cursor: Optional[types.AutomationLogsWhereUniqueInput] = None,
        include: Optional[types.AutomationLogsInclude] = None,
        order: Optional[Union[types.AutomationLogsOrderByInput, List[types.AutomationLogsOrderByInput]]] = None,
        distinct: Optional[List[types.AutomationLogsScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AutomationLogs record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AutomationLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AutomationLogs model
        order
            Order the returned AutomationLogs records by any field
        distinct
            Filter AutomationLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AutomationLogs
            The first AutomationLogs record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AutomationLogs record ordered by the status field
        automationlogs = await AutomationLogs.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AutomationLogsWhereInput] = None,
        cursor: Optional[types.AutomationLogsWhereUniqueInput] = None,
        include: Optional[types.AutomationLogsInclude] = None,
        order: Optional[Union[types.AutomationLogsOrderByInput, List[types.AutomationLogsOrderByInput]]] = None,
        distinct: Optional[List[types.AutomationLogsScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AutomationLogs record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AutomationLogs filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AutomationLogs model
        order
            Order the returned AutomationLogs records by any field
        distinct
            Filter AutomationLogs records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AutomationLogs
            The first AutomationLogs record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AutomationLogs record ordered by the details field
        automationlogs = await AutomationLogs.prisma().find_first_or_raise(
            skip=1,
            order={
                'details': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AutomationLogsUpdateInput,
        where: types.AutomationLogsWhereUniqueInput,
        include: Optional[types.AutomationLogsInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AutomationLogs record.

        Parameters
        ----------
        data
            AutomationLogs record data specifying what to update
        where
            AutomationLogs filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AutomationLogs model

        Returns
        -------
        prisma.models.AutomationLogs
            The updated AutomationLogs record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        automationlogs = await AutomationLogs.prisma().update(
            where={
                'id': 2070408293,
            },
            data={
                # data to update the AutomationLogs record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AutomationLogsWhereUniqueInput,
        data: types.AutomationLogsUpsertInput,
        include: Optional[types.AutomationLogsInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AutomationLogs filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AutomationLogs model

        Returns
        -------
        prisma.models.AutomationLogs
            The created or updated AutomationLogs record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        automationlogs = await AutomationLogs.prisma().upsert(
            where={
                'id': 811900218,
            },
            data={
                'create': {
                    'id': 811900218,
                    'ruleId': 864576371,
                    'action': 'ejbiifbae',
                    'status': 'djcfgedjd',
                },
                'update': {
                    'ruleId': 864576371,
                    'action': 'ejbiifbae',
                    'status': 'djcfgedjd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AutomationLogsUpdateManyMutationInput,
        where: types.AutomationLogsWhereInput,
    ) -> int:
        """Update multiple AutomationLogs records

        Parameters
        ----------
        data
            AutomationLogs data to update the selected AutomationLogs records to
        where
            Filter to select the AutomationLogs records to update

        Returns
        -------
        int
            The total number of AutomationLogs records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AutomationLogs records
        total = await AutomationLogs.prisma().update_many(
            data={
                'error': 'djgacbcch'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomationLogsWhereInput] = None,
        cursor: Optional[types.AutomationLogsWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AutomationLogs records present in the database

        Parameters
        ----------
        select
            Select the AutomationLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AutomationLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AutomationLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AutomationLogs.prisma().count()

        # results: prisma.types.AutomationLogsCountAggregateOutput
        results = await AutomationLogs.prisma().count(
            select={
                '_all': True,
                'executedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AutomationLogsCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomationLogsWhereInput] = None,
        cursor: Optional[types.AutomationLogsWhereUniqueInput] = None,
    ) -> types.AutomationLogsCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AutomationLogsCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AutomationLogsWhereInput] = None,
        cursor: Optional[types.AutomationLogsWhereUniqueInput] = None,
    ) -> Union[int, types.AutomationLogsCountAggregateOutput]:
        """Count the number of AutomationLogs records present in the database

        Parameters
        ----------
        select
            Select the AutomationLogs fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AutomationLogs filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AutomationLogsCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AutomationLogs.prisma().count()

        # results: prisma.types.AutomationLogsCountAggregateOutput
        results = await AutomationLogs.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AutomationLogsCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AutomationLogsWhereInput] = None
    ) -> int:
        """Delete multiple AutomationLogs records.

        Parameters
        ----------
        where
            Optional AutomationLogs filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AutomationLogs records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AutomationLogs records
        total = await AutomationLogs.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AutomationLogsScalarFieldKeys'],
        *,
        where: Optional['types.AutomationLogsWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AutomationLogsAvgAggregateInput'] = None,
        sum: Optional['types.AutomationLogsSumAggregateInput'] = None,
        min: Optional['types.AutomationLogsMinAggregateInput'] = None,
        max: Optional['types.AutomationLogsMaxAggregateInput'] = None,
        having: Optional['types.AutomationLogsScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AutomationLogsCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AutomationLogsScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AutomationLogsScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AutomationLogsGroupByOutput']:
        """Group AutomationLogs records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AutomationLogs fields to group records by
        where
            AutomationLogs filter to select records
        take
            Limit the maximum number of AutomationLogs records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AutomationLogsGroupByOutput]
            A list of dictionaries representing the AutomationLogs record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AutomationLogs records by ruleId values
        # and count how many records are in each group
        results = await AutomationLogs.prisma().group_by(
            ['ruleId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ContentTemplatesActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ContentTemplates]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ContentTemplates.prisma().query_raw(
            'SELECT * FROM ContentTemplates WHERE id = $1',
            644446024,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ContentTemplates
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ContentTemplates.prisma().query_first(
            'SELECT * FROM ContentTemplates WHERE name = $1',
            'bbgdigchd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ContentTemplatesCreateInput,
        include: Optional[types.ContentTemplatesInclude] = None
    ) -> _PrismaModelT:
        """Create a new ContentTemplates record.

        Parameters
        ----------
        data
            ContentTemplates record data
        include
            Specifies which relations should be loaded on the returned ContentTemplates model

        Returns
        -------
        prisma.models.ContentTemplates
            The created ContentTemplates record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ContentTemplates record from just the required fields
        contenttemplates = await ContentTemplates.prisma().create(
            data={
                # data to create a ContentTemplates record
                'name': 'dajcifgdi',
                'type': 'ccedhdbj',
                'template': 'bjaabjjjce',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ContentTemplatesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ContentTemplates records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ContentTemplates record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ContentTemplates.prisma().create_many(
            data=[
                {
                    # data to create a ContentTemplates record
                    'name': 'cafhdcdcjd',
                    'type': 'bdeebbhbdi',
                    'template': 'cafcbdchah',
                },
                {
                    # data to create a ContentTemplates record
                    'name': 'bdffbehbae',
                    'type': 'ieahjgeb',
                    'template': 'hfeeddceg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ContentTemplatesWhereUniqueInput,
        include: Optional[types.ContentTemplatesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ContentTemplates record.

        Parameters
        ----------
        where
            ContentTemplates filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ContentTemplates model

        Returns
        -------
        prisma.models.ContentTemplates
            The deleted ContentTemplates record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contenttemplates = await ContentTemplates.prisma().delete(
            where={
                'id': 314261183,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ContentTemplatesWhereUniqueInput,
        include: Optional[types.ContentTemplatesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ContentTemplates record.

        Parameters
        ----------
        where
            ContentTemplates filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ContentTemplates model

        Returns
        -------
        prisma.models.ContentTemplates
            The found ContentTemplates record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contenttemplates = await ContentTemplates.prisma().find_unique(
            where={
                'id': 227678604,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ContentTemplatesWhereUniqueInput,
        include: Optional[types.ContentTemplatesInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ContentTemplates record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ContentTemplates filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ContentTemplates model

        Returns
        -------
        prisma.models.ContentTemplates
            The found ContentTemplates record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contenttemplates = await ContentTemplates.prisma().find_unique_or_raise(
            where={
                'id': 423999701,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContentTemplatesWhereInput] = None,
        cursor: Optional[types.ContentTemplatesWhereUniqueInput] = None,
        include: Optional[types.ContentTemplatesInclude] = None,
        order: Optional[Union[types.ContentTemplatesOrderByInput, List[types.ContentTemplatesOrderByInput]]] = None,
        distinct: Optional[List[types.ContentTemplatesScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ContentTemplates records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ContentTemplates records returned
        skip
            Ignore the first N results
        where
            ContentTemplates filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ContentTemplates model
        order
            Order the returned ContentTemplates records by any field
        distinct
            Filter ContentTemplates records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ContentTemplates]
            The list of all ContentTemplates records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ContentTemplates records
        contenttemplates = await ContentTemplates.prisma().find_many(take=10)

        # find the first 5 ContentTemplates records ordered by the type field
        contenttemplates = await ContentTemplates.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContentTemplatesWhereInput] = None,
        cursor: Optional[types.ContentTemplatesWhereUniqueInput] = None,
        include: Optional[types.ContentTemplatesInclude] = None,
        order: Optional[Union[types.ContentTemplatesOrderByInput, List[types.ContentTemplatesOrderByInput]]] = None,
        distinct: Optional[List[types.ContentTemplatesScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ContentTemplates record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ContentTemplates filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ContentTemplates model
        order
            Order the returned ContentTemplates records by any field
        distinct
            Filter ContentTemplates records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ContentTemplates
            The first ContentTemplates record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ContentTemplates record ordered by the template field
        contenttemplates = await ContentTemplates.prisma().find_first(
            skip=1,
            order={
                'template': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ContentTemplatesWhereInput] = None,
        cursor: Optional[types.ContentTemplatesWhereUniqueInput] = None,
        include: Optional[types.ContentTemplatesInclude] = None,
        order: Optional[Union[types.ContentTemplatesOrderByInput, List[types.ContentTemplatesOrderByInput]]] = None,
        distinct: Optional[List[types.ContentTemplatesScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ContentTemplates record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ContentTemplates filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ContentTemplates model
        order
            Order the returned ContentTemplates records by any field
        distinct
            Filter ContentTemplates records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ContentTemplates
            The first ContentTemplates record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ContentTemplates record ordered by the variables field
        contenttemplates = await ContentTemplates.prisma().find_first_or_raise(
            skip=1,
            order={
                'variables': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ContentTemplatesUpdateInput,
        where: types.ContentTemplatesWhereUniqueInput,
        include: Optional[types.ContentTemplatesInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ContentTemplates record.

        Parameters
        ----------
        data
            ContentTemplates record data specifying what to update
        where
            ContentTemplates filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ContentTemplates model

        Returns
        -------
        prisma.models.ContentTemplates
            The updated ContentTemplates record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        contenttemplates = await ContentTemplates.prisma().update(
            where={
                'id': 180275434,
            },
            data={
                # data to update the ContentTemplates record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ContentTemplatesWhereUniqueInput,
        data: types.ContentTemplatesUpsertInput,
        include: Optional[types.ContentTemplatesInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ContentTemplates filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ContentTemplates model

        Returns
        -------
        prisma.models.ContentTemplates
            The created or updated ContentTemplates record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contenttemplates = await ContentTemplates.prisma().upsert(
            where={
                'id': 57608155,
            },
            data={
                'create': {
                    'id': 57608155,
                    'name': 'bdffbehbae',
                    'type': 'ieahjgeb',
                    'template': 'hfeeddceg',
                },
                'update': {
                    'name': 'bdffbehbae',
                    'type': 'ieahjgeb',
                    'template': 'hfeeddceg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ContentTemplatesUpdateManyMutationInput,
        where: types.ContentTemplatesWhereInput,
    ) -> int:
        """Update multiple ContentTemplates records

        Parameters
        ----------
        data
            ContentTemplates data to update the selected ContentTemplates records to
        where
            Filter to select the ContentTemplates records to update

        Returns
        -------
        int
            The total number of ContentTemplates records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ContentTemplates records
        total = await ContentTemplates.prisma().update_many(
            data={
                'isActive': True
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContentTemplatesWhereInput] = None,
        cursor: Optional[types.ContentTemplatesWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ContentTemplates records present in the database

        Parameters
        ----------
        select
            Select the ContentTemplates fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ContentTemplates filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContentTemplatesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ContentTemplates.prisma().count()

        # results: prisma.types.ContentTemplatesCountAggregateOutput
        results = await ContentTemplates.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ContentTemplatesCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContentTemplatesWhereInput] = None,
        cursor: Optional[types.ContentTemplatesWhereUniqueInput] = None,
    ) -> types.ContentTemplatesCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ContentTemplatesCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ContentTemplatesWhereInput] = None,
        cursor: Optional[types.ContentTemplatesWhereUniqueInput] = None,
    ) -> Union[int, types.ContentTemplatesCountAggregateOutput]:
        """Count the number of ContentTemplates records present in the database

        Parameters
        ----------
        select
            Select the ContentTemplates fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ContentTemplates filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ContentTemplatesCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ContentTemplates.prisma().count()

        # results: prisma.types.ContentTemplatesCountAggregateOutput
        results = await ContentTemplates.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ContentTemplatesCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ContentTemplatesWhereInput] = None
    ) -> int:
        """Delete multiple ContentTemplates records.

        Parameters
        ----------
        where
            Optional ContentTemplates filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ContentTemplates records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ContentTemplates records
        total = await ContentTemplates.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ContentTemplatesScalarFieldKeys'],
        *,
        where: Optional['types.ContentTemplatesWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ContentTemplatesAvgAggregateInput'] = None,
        sum: Optional['types.ContentTemplatesSumAggregateInput'] = None,
        min: Optional['types.ContentTemplatesMinAggregateInput'] = None,
        max: Optional['types.ContentTemplatesMaxAggregateInput'] = None,
        having: Optional['types.ContentTemplatesScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ContentTemplatesCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ContentTemplatesScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ContentTemplatesScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ContentTemplatesGroupByOutput']:
        """Group ContentTemplates records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ContentTemplates fields to group records by
        where
            ContentTemplates filter to select records
        take
            Limit the maximum number of ContentTemplates records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ContentTemplatesGroupByOutput]
            A list of dictionaries representing the ContentTemplates record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ContentTemplates records by id values
        # and count how many records are in each group
        results = await ContentTemplates.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models